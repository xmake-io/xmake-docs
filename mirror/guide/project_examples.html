<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xmake</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="/assets/npm/github-markdown/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h4>This is a mirror page, please see the original page: </h4><a href="https://xmake.io/#/guide/project_examples">https://xmake.io/#/guide/project_examples</a>
<div id="wwads-panel" class="wwads-cn wwads-vertical wwads-sticky" data-id="239" style="max-width:180px;bottom:20px;right:20px;width:200px;height:260px;background:#fff;position:fixed"></div>
</br>
    <script type="text/javascript" charset="UTF-8" src="https://cdn.wwads.cn/js/makemoney.js" async></script>
<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <h1 id="projectexamples">Project examples</h1>
<p>We briefly introduce some commonly used project examples. More and more complete examples projects can be viewed in <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects">project examples</a>.</p>
<p>We can also use the <code>xmake create</code> command to create various commonly used empty projects to quickly start. For the introduction of this command and the supported project templates, you can type the following command to view:</p>
<pre><code class="lang-bash">xmake create --help
</code></pre>
<h2 id="executableprogram">Executable Program</h2>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("src/*.c")
</code></pre>
<p>For a complete example, execute the following command to create:</p>
<pre><code class="lang-bash">xmake create -l c -t console test
</code></pre>
<h2 id="staticlibraryprogram">Static Library Program</h2>
<pre><code class="lang-lua">target("library")
    set_kind("static")
    add_files("src/library/*.c")

target("test")
    set_kind("binary")
    add_files("src/*.c")
    add_deps("library")
</code></pre>
<p>We use <code>add_deps</code> to link a static library to test target.</p>
<p>For a complete example, execute the following command to create:</p>
<pre><code class="lang-bash">xmake create -l c -t static test
</code></pre>
<h2 id="sharedlibraryprogram">Shared Library Program</h2>
<pre><code class="lang-lua">target("library")
    set_kind("shared")
    add_files("src/library/*.c")

target("test")
    set_kind("binary")
    add_files("src/*.c")
    add_deps("library")
</code></pre>
<p>We use <code>add_deps</code> to link a shared library to test target.</p>
<p>For a complete example, execute the following command to create:</p>
<pre><code class="lang-bash">xmake create -l c -t shared test
</code></pre>
<h2 id="wasmprograms">Wasm programs</h2>
<p>All c/c++ programs can be compiled to Wasm without any xmake.lua configuration changes, just switch to the wasm compilation platform and compile.</p>
<pre><code class="lang-bash">$ xmake f -p wasm
$ xmake
</code></pre>
<p>For detailed wasm compilation configuration see: <a href="/mirror/guide/configuration.html#wasm">wasm configuration</a></p>
<p>Alternatively, when compiling a file with the <code>-preload-file assets/xxx.md</code> setting, we can also simplify its setup by configuring</p>
<pre><code class="lang-lua">target("test5")
    set_kind("binary")
    add_files("src/*.cpp")
    add_values("wasm.preloadfiles", "src/xxx.md")
    add_values("wasm.preloadfiles", "src/xxx2.md")
</code></pre>
<h2 id="qtprogram">Qt Program</h2>
<p>Create an empty project:</p>
<p>v2.2.9 or higher:</p>
<pre><code class="lang-bash">$ xmake create -t qt.console test
$ xmake create -t qt.static test
$ xmake create -t qt.shared test
$ xmake create -t qt.quickapp test
$ xmake create -t qt.widgetapp test
</code></pre>
<p>For more project templates see: <code>xmake create --help</code></p>
<p>Older version of v2.2.8:</p>
<pre><code class="lang-bash">$ xmake create -l c++ -t console_qt test
$ xmake create -l c++ -t static_qt test
$ xmake create -l c++ -t shared_qt test
$ xmake create -l c++ -t quickapp_qt test
</code></pre>
<p>xmake will detect Qt SDK automatically and we can also set the SDK directory manually.</p>
<pre><code class="lang-bash">$ xmake f --qt=~/Qt/Qt5.9.1
</code></pre>
<p>The MingW SDK specified above uses the environment that comes with the Tools directory under Qt. Of course, if there are other third-party MingW compilation environments, they can also be specified manually.<br>For details, please refer to: <a href="/mirror/guide/configuration.html#mingw">MingW Configuration</a>.</p>
<p>For more details, please refer to: <a href="https://github.com/xmake-io/xmake/issues/160">#160</a></p>
<p>In addition, currently xmake also supports Qt/Wasm. For details, see: <a href="/mirror/guide/configuration.html#wasm">Wasm Configuration</a></p>
<pre><code class="lang-bash">$ xmake f -p wasm
</code></pre>
<h3 id="staticlibrary">Static Library</h3>
<pre><code class="lang-lua">target("qt_static_library")
    add_rules("qt.static")
    add_files("src/*.cpp")
    add_frameworks("QtNetwork", "QtGui")
</code></pre>
<h3 id="sharedlibrary">Shared Library</h3>
<pre><code class="lang-lua">target("qt_shared_library")
    add_rules("qt.shared")
    add_files("src/*.cpp")
    add_frameworks("QtNetwork", "QtGui")
</code></pre>
<h3 id="consoleprogram">Console Program</h3>
<pre><code class="lang-lua">target("qt_console")
    add_rules("qt.console")
    add_files("src/*.cpp")
</code></pre>
<h3 id="quickapplication">Quick Application</h3>
<p>v2.2.9 or higher:</p>
<pre><code class="lang-lua">target("qt_quickapp")
    add_rules("qt.quickapp")
    add_files("src/*.cpp")
    add_files("src/qml.qrc")
</code></pre>
<p>!> If you are using your own compiled static version of the QT SDK, you need to switch to the <code>add_rules("qt.quickapp_static")</code> static rule,<br>because the linked libraries are different and need to be statically linked.</p>
<p>Next, we try to compile, usually, if you use the Qt installation package to install by default, and do not modify the installation path, then in most cases you can automatically detect the root path of the QT SDK, for example:</p>
<pre><code class="lang-bash">$ xmake
checking for the architecture ... x86_64
checking for the Xcode directory ... /Applications/Xcode.app
checking for the SDK version of Xcode ... 10.15
checking for the Qt SDK directory ... /Users/ruki/Qt5.13.2/5.13.2/clang_64
checking for the Qt SDK version ... 5.13.2
[0%]: cache compiling.release src/main.cpp
[49%]: compiling.qt.qrc src/qml.qrc
[100%]: linking.release test
Build ok!
</code></pre>
<p>Then we continue to run it:</p>
<pre><code class="lang-bash">$ xmake run
</code></pre>
<p>The effect is as follows:</p>
<p><img src="/assets/img/guide/qt_quickapp.png" alt=""></p>
<h3 id="quickplugin">Quick Plugin</h3>
<p>For a full example see: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/qt/quickplugin">quickplugin example</a></p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("demo")
    add_rules("qt.qmlplugin")
    add_headerfiles("src/*.h")
    add_files("src/*.cpp")

    set_values("qt.qmlplugin.import_name", "My.Plugin")
</code></pre>
<h3 id="widgetsapplication">Widgets Application</h3>
<p>v2.2.9 or higher:</p>
<pre><code class="lang-lua">target("qt_widgetapp")
    add_rules("qt.widgetapp")
    add_headerfiles("src/*.h")
    add_files("src/*.cpp")
    add_files("src/mainwindow.ui")
    -- add files with Q_OBJECT meta (only for qt.moc)
    add_files("src/mainwindow.h")
</code></pre>
<p>!> The new version provides the <code>qt.widgetapp</code> rule, built-in QtWidgets built-in rules, the use of simpler, the following version of the <code>qt.application</code> is still supported, backward compatible:</p>
<pre><code class="lang-lua">target("qt_widgetapp")
    add_rules("qt.application")
    add_files("src/*.cpp")
    add_files("src/mainwindow.ui")
    add_files("src/mainwindow.h")  -- add files with Q_OBJECT meta (only for qt.moc)
    add_frameworks("QtWidgets")
</code></pre>
<p>!> If you are using your own compiled static version of the QT SDK, you need to switch to the <code>add_rules("qt.widgetapp_static")</code> static rule,<br>because the linked libraries are different and need to be statically linked.</p>
<p>The effect is as follows:</p>
<p><img src="/assets/img/guide/qt_widgetapp.png" alt=""></p>
<h3 id="androidapplication">Android Application</h3>
<p>After the 2.2.6 version, you can directly switch to the android platform to compile the Quick/Widgets application, generate the apk package, and install it to the device via the <code>xmake install</code> command.</p>
<pre><code class="lang-bash">$ xmake create -t quickapp_qt -l c ++ appdemo
$ cd appdemo
$ xmake f -p android --ndk=~/Downloads/android-ndk-r19c/ --android_sdk=~/Library/Android/sdk/ -c
$ xmake
[0%]: compiling.qt.qrc src/qml.qrc
[ 50%]: cache compiling.release src/main.cpp
[100%]: linking.release libappdemo.so
[100%]: generating.qt.app appdemo.apk
</code></pre>
<p>Then install to the device:</p>
<pre><code class="lang-bash">$ xmake install
installing appdemo ...
installing build/android/release/appdemo.apk ..
success
install ok!👌
</code></pre>
<h3 id="supportedqtsdks">Supported Qt SDKs</h3>
<h4 id="theofficialqtsdkinstallationpackage">The official Qt SDK installation package</h4>
<p>This is usually detected automatically on macos/windows, but it is possible to specify the Qt SDK path manually.</p>
<pre><code class="lang-bash">$ xmake f --qt=[qt sdk path]
</code></pre>
<h4 id="theubuntuaptpackage">The Ubuntu Apt package</h4>
<p>After installing the Qt SDK using apt, xmake will also be able to detect it automatically.</p>
<pre><code class="lang-bash">$ sudo apt install -y qtcreator qtbase5-dev
$ xmake
</code></pre>
<h4 id="qtmingwsdkfrommsys2pacman">Qt Mingw SDK from msys2/pacman</h4>
<p>xmake also supports the Qt Mingw SDK installed from pacman</p>
<pre><code class="lang-bash">$ pacman -S mingw-w64-x86_64-qt5 mingw-w64-x86_64-qt-creator
$ xmake
</code></pre>
<h4 id="qtsdkpackagefromaqtinstallscript">Qt SDK package from aqtinstall script</h4>
<p>The Qt SDK installed by <a href="https://github.com/miurahr/aqtinstall">aqtinstall</a> is based entirely on the official SDK structure and is therefore fully supported by xmake.</p>
<p>However, it is usually necessary to specify the SDK path yourself.</p>
<pre><code class="lang-bash">$ xmake f --qt=[Qt SDK]
</code></pre>
<h4 id="qtpackagesfromthexmakereporepository">Qt packages from the xmake-repo repository</h4>
<p>xmake now officially provides a variety of modules for the Qt5 SDK that can be integrated automatically without any manual installation.</p>
<p>Just configure the integration packages and xmake will automatically handle the Qt installation and integration and compile the project automatically.</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

add_requires("qt5widgets")

target("test")
    add_rules("qt.widgetapp")
    add_packages("qt5widgets")

    add_headerfiles("src/*.h")
    add_files("src/*.cpp")
    add_files("src/mainwindow.ui")
    -- add files with Q_OBJECT meta (only for qt.moc)
    add_files("src/mainwindow.h")
</code></pre>
<p>In addition to the <code>qt5widgets</code> package, the repository also provides <code>qt5gui</code>, <code>qt5network</code> and other packages that can be used.</p>
<p>Once configured, simply execute:</p>
<pre><code class="lang-bash">$ xmake
</code></pre>
<p>!> The Qt6 package is still under development and only supports Qt5 for now</p>
<h4 id="qtpackagesfromvcpkgconan">Qt packages from vcpkg/conan</h4>
<p>There is no time to support it yet, so please try to integrate the Qt SDK in the same way as above.</p>
<h2 id="wdkdriverprogram">WDK Driver Program</h2>
<p>xmake will detect WDK automatically and we can also set the WDK directory manually.</p>
<pre><code class="lang-bash">$ xmake f --wdk="G:\Program Files\Windows Kits\10" -c
$ xmake
</code></pre>
<p>If you want to known more information, you can see <a href="https://github.com/xmake-io/xmake/issues/159">#159</a>.</p>
<p>And see <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/windows/driver">WDK examples</a></p>
<h3 id="umdfdriverprogram">UMDF Driver Program</h3>
<pre><code class="lang-lua">target("echo")
    add_rules("wdk.driver", "wdk.env.umdf")
    add_files("driver/*.c")
    add_files("driver/*.inx")
    add_includedirs("exe")

target("app")
    add_rules("wdk.binary", "wdk.env.umdf")
    add_files("exe/*.cpp")
</code></pre>
<h3 id="kmdfdriverprogram">KMDF Driver Program</h3>
<pre><code class="lang-lua">target("nonpnp")
    add_rules("wdk.driver", "wdk.env.kmdf")
    add_values("wdk.tracewpp.flags", "-func:TraceEvents(LEVEL,FLAGS,MSG,...)", "-func:Hexdump((LEVEL,FLAGS,MSG,...))")
    add_files("driver/*.c", {rule = "wdk.tracewpp"})
    add_files("driver/*.rc")

target("app")
    add_rules("wdk.binary", "wdk.env.kmdf")
    add_files("exe/*.c")
    add_files("exe/*.inf")
</code></pre>
<h3 id="wdmdriverprogram">WDM Driver Program</h3>
<pre><code class="lang-lua">target("kcs")
    add_rules("wdk.driver", "wdk.env.wdm")
    add_values("wdk.man.flags", "-prefix Kcs")
    add_values("wdk.man.resource", "kcsCounters.rc")
    add_values("wdk.man.header", "kcsCounters.h")
    add_values("wdk.man.counter_header", "kcsCounters_counters.h")
    add_files("*.c", "*.rc", "*.man")
</code></pre>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    add_values("wdk.tracewpp.flags", "-func:TracePrint((LEVEL,FLAGS,MSG,...))")
    add_files("*.c", {rule = "wdk.tracewpp"})
    add_files("*.rc", "*.inf")
    add_files("*.mof|msdsm.mof")
    add_files("msdsm.mof", {values = {wdk_mof_header = "msdsmwmi.h"}})
</code></pre>
<h3 id="packagedriver">Package Driver</h3>
<p>We can run the following command to generate a .cab driver package.</p>
<pre><code class="lang-bash">$ xmake [p|package]
$ xmake [p|package] -o outputdir
</code></pre>
<p>The output files like:</p>
<pre><code>  - drivers
    - sampledsm
       - debug/x86/sampledsm.cab
       - release/x64/sampledsm.cab
       - debug/x86/sampledsm.cab
       - release/x64/sampledsm.cab
</code></pre><h3 id="driversigning">Driver Signing</h3>
<p>The driver signing is disabled when we compile driver in default case,<br>but we can add <code>set_values("wdk.sign.mode")</code> to enable test/release sign.</p>
<h4 id="testsign">TestSign</h4>
<p>We can use test certificate of xmake to do testsign, but please run <code>$xmake l utils.wdk.testcert</code> install as admin to install a test certificate first (only once)!</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "test")
</code></pre>
<p>Or we set a valid certificate thumbprint to do it in local machine.</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "test")
    set_values("wdk.sign.thumbprint", "032122545DCAA6167B1ADBE5F7FDF07AE2234AAA")
</code></pre>
<p>We can also do testsign via setting store/company info.</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "test")
    set_values("wdk.sign.store", "PrivateCertStore")
    set_values("wdk.sign.company", "tboox.org(test)")
</code></pre>
<h4 id="releasesign">ReleaseSign</h4>
<p>We can set a certificate file for release signing.</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "release")
    set_values("wdk.sign.company", "xxxx")
    set_values("wdk.sign.certfile", path.join(os.projectdir(), "xxxx.cer"))
</code></pre>
<h3 id="supportlowversionsystem">Support Low-version System</h3>
<p>We can set <code>wdk.env.winver</code> to generate a driver package that is compatible with a low version system.</p>
<pre><code class="lang-lua">set_values("wdk.env.winver", "win10")
set_values("wdk.env.winver", "win10_rs3")
set_values("wdk.env.winver", "win81")
set_values("wdk.env.winver", "win8")
set_values("wdk.env.winver", "win7")
set_values("wdk.env.winver", "win7_sp1")
set_values("wdk.env.winver", "win7_sp2")
set_values("wdk.env.winver", "win7_sp3")
</code></pre>
<p>We can also set windows version for WDK driver program:</p>
<pre><code class="lang-bash">$ xmake f --wdk_winver=[win10_rs3|win8|win7|win7_sp1]
$ xmake
</code></pre>
<h2 id="winsdkapplicationprogram">WinSDK Application Program</h2>
<pre><code class="lang-lua">target("usbview")
    add_rules("win.sdk.application")

    add_files("*.c", "*.rc")
    add_files("xmlhelper.cpp", {rule = "win.sdk.dotnet"})
</code></pre>
<p>If you want to known more information, you can see <a href="https://github.com/xmake-io/xmake/issues/173">#173</a>.</p>
<h2 id="mfcapplicationprogram">MFC Application Program</h2>
<h3 id="mfcstaticlibrary">MFC Static Library</h3>
<pre><code class="lang-lua">target("test")
    add_rules("win.sdk.mfc.static")
    add_files("src/*.c")
</code></pre>
<h3 id="mfcsharedlibrary">MFC Shared Library</h3>
<pre><code class="lang-lua">target("test")
    add_rules("win.sdk.mfc.shared")
    add_files("src/*.c")
</code></pre>
<h3 id="mfcapplicationstatic">MFC Application (Static)</h3>
<pre><code class="lang-lua">target("test")
    add_rules("win.sdk.mfc.static_app")
    add_files("src/*.c")
</code></pre>
<h3 id="mfcapplicationshared">MFC Application (Shared)</h3>
<pre><code class="lang-lua">target("test")
    add_rules("win.sdk.mfc.shared_app")
    add_files("src/*.c")
</code></pre>
<h2 id="iosmacosprogram">iOS/MacOS Program</h2>
<h3 id="application">Application</h3>
<p>Generate <em>.app/</em>.ipa application and supports iOS/MacOS.</p>
<pre><code class="lang-lua">target("test")
    add_rules("xcode.application")
    add_files("src/*.m", "src/**.storyboard", "src/*.xcassets")
    add_files("src/Info.plist")
</code></pre>
<p>!> After 2.5.7, you can directly add <code>*.metal</code> files, xmake will automatically generate default.metallib for the application to load and use.</p>
<h4 id="createproject">Create Project</h4>
<p>We can also quickly create project through template:</p>
<pre><code class="lang-bash">$ xmake create -t xcode.macapp -l objc test
$ xmake create -t xcode.iosapp -l objc test
</code></pre>
<h4 id="buildprogram">Build Program</h4>
<pre><code class="lang-bash">$ xmake f -p [iphoneos|macosx]
$ xmake
[ 18%]: compiling.xcode.release src/Assets.xcassets
[ 27%]: processing.xcode.release src/Info.plist
[ 72%]: compiling.xcode.release src/Base.lproj/Main.storyboard
[ 81%]: compiling.xcode.release src/Base.lproj/LaunchScreen.storyboard
[ 45%]: cache compiling.release src/ViewController.m
[ 63%]: cache compiling.release src/AppDelegate.m
[ 54%]: cache compiling.release src/SceneDelegate.m
[ 36%]: cache compiling.release src/main.m
[ 90%]: linking.release test
[100%]: generating.xcode.release test.app
[100%]: build ok!
</code></pre>
<h4 id="codesign">Codesign</h4>
<p>For iOS programs, it will detect that the system first signs the app with available signatures. Of course, we can also manually specify other signature certificates:</p>
<pre><code class="lang-bash">$ xmake f -p iphoneos --xcode_codesign_identity=&#39;Apple Development: xxx@gmail.com (T3NA4MRVPU)&#39; --xcode_mobile_provision=&#39;iOS Team Provisioning Profile: org.tboox.test --xcode_bundle_identifier=org.tboox.test&#39;
$ xmake
</code></pre>
<p>If it is cumbersome to configure the signature every time, you can set it to the <code>xmake global</code> global configuration, or you can set it separately for each target in xmake.lua:</p>
<pre><code class="lang-lua">target("test")
    add_rules("xcode.application")
    add_files("src/*.m", "src/**.storyboard", "src/*.xcassets")
    add_files("src/Info.plist")
    add_values("xcode.bundle_identifier", "org.tboox.test")
    add_values("xcode.codesign_identity", "Apple Development: xxx@gmail.com (T3NA4MRVPU)")
    add_values("xcode.mobile_provision", "iOS Team Provisioning Profile: org.tboox.test")
</code></pre>
<p>How do we know the signature configuration we need? One is to view it in xcode. In addition, xmake also provides some auxiliary tools to dump all currently available signature configurations:</p>
<pre><code class="lang-bash">$ xmake l private.tools.codesign.dump
==================================== codesign identities ====================================
{
  "Apple Development: waruqi@gmail.com (T3NA4MRVPU)" = "AF73C231A0C35335B72761BD3759694739D34EB1"
}

===================================== mobile provisions =====================================
{
  "iOS Team Provisioning Profile: org.tboox.test" = "<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>AppIDName</key>
    <string>XC org tboox test</string>
    <key>ApplicationIdentifierPrefix</key>
    <array>
    <string>43AAQM58X3</string>
...
</code></pre>
<p>We also provide other auxiliary tools to re-sign existing ipa / app programs, for example:</p>
<pre><code class="lang-bash">$ xmake l utils.ipa.resign test.ipa | test.app [codesign_identity] [mobile_provision] [bundle_identifier]
</code></pre>
<p>Among them, the following signature parameters are optional, if not set, then a valid signature will be detected by default:</p>
<pre><code class="lang-bash">$ xmake l utils.ipa.resign test.ipa
$ xmake l utils.ipa.resign test.app "Apple Development: waruqi@gmail.com (T3NA4MRVPU)"
$ xmake l utils.ipa.resign test.ipa "Apple Development: waruqi@gmail.com (T3NA4MRVPU)" iOS Team Provisioning Profile: org.tboox.test" org.tboox.test
</code></pre>
<h4 id="runtheapplication">Run the application</h4>
<p>Currently only supports running macos program:</p>
<p><code>`console
$ xmake run</code> `</p>
<p>The effect is as follows:</p>
<p><img src="/assets/img/guide/macapp.png" alt=""></p>
<h4 id="packageprogram">Package program</h4>
<p>If it is an iOS program, it will generate an ipa installation package, if it is macOS, it will generate a dmg package (dmg package generation is still under development for the time being).</p>
<pre><code class="lang-bash">$ xmake package
output: build/iphoneos/release/arm64/test.ipa
package ok!
</code></pre>
<p>We also provide auxiliary tools to package the specified app program:</p>
<pre><code class="lang-bash">$ xmake l utils.ipa.package test.app output.ipa [iconfile.png]
</code></pre>
<h4 id="install">Install</h4>
<p>If it is an iOS program, it will install ipa to the device, if it is macos, it will install the app to the <code>/Applications</code> directory.</p>
<pre><code class="lang-bash">$ xmake install
</code></pre>
<p>We also provide auxiliary tools to install the specified ipa/app program to the device:</p>
<pre><code class="lang-bash">$ xmake l utils.ipa.install test.app
$ xmake l utils.ipa.install test.ipa
</code></pre>
<h4 id="uninstall">Uninstall</h4>
<p>!> Currently only the macos program is supported</p>
<pre><code class="lang-bash">$ xmake uninstall
</code></pre>
<h3 id="frameworkprogram">Framework Program</h3>
<pre><code class="lang-lua">target("test")
    add_rules("xcode.framework")
    add_files("src/*.m")
    add_files("src/Info.plist")
</code></pre>
<p>We can also quickly create project through template:</p>
<pre><code class="lang-bash">$ xmake create -t xcode.framework -l objc test
</code></pre>
<p>In addition, xmake v2.3.9 and above, xmake also provides a complete iosapp/macapp empty project template with framework library usage, you can fully experience framework compilation, dependent use and integration into app applications.</p>
<p>At the same time, if we turn on the emulator, xmake can support directly <code>xmake install</code> and <code>xmake run</code> to install the app to the emulator and load and run it.</p>
<pre><code class="lang-bash">$ xmake create -t xcode.iosapp_with_framework -l objc testapp
$ cd testapp
$ xmake f -p iphoneos -a x86_64
$ xmake
$ xmake install
$ xmake run
</code></pre>
<h3 id="bundleprogram">Bundle Program</h3>
<pre><code class="lang-lua">target("test")
    add_rules("xcode.bundle")
    add_files("src/*.m")
    add_files("src/Info.plist")
</code></pre>
<p>We can also quickly create project through template:</p>
<pre><code class="lang-bash">$ xmake create -t xcode.bundle -l objc test
</code></pre>
<h2 id="protobufprogram">Protobuf Program</h2>
<h3 id="usingclibrary">Using c library</h3>
<pre><code class="lang-lua">add_requires("protobuf-c")

target("console_c")
     set_kind("binary")
     add_packages("protobuf-c")
     add_rules("protobuf.c")
     add_files("src/*.c")
     add_files("src/*.proto")
</code></pre>
<p>We can also set <code>proto_public = true</code> to export the proto&#39;s header search directory and make it available for other parent targets to inherit from.</p>
<pre><code class="lang-lua">    add_packages("protobuf-c", {public = true})
    add_files("src/**.proto", {proto_public = true})
</code></pre>
<p>Note: Since the headers generated by protobuf reference the headers of the protobuf-c package, we also need to mark the package headers as <code>{public = true}</code> to export it.</p>
<h3 id="usingtheclibrary">Using the C++ library</h3>
<pre><code class="lang-lua">add_requires("protobuf-cpp")

target("console_c++")
     set_kind("binary")
     set_languages("c++11")
     add_packages("protobuf-cpp")
     add_rules("protobuf.cpp")
     add_files("src/*.cpp")
     add_files("src/*.proto")
</code></pre>
<p>We can also set <code>proto_public = true</code> to export the proto&#39;s header search directory and make it available for other parent targets to inherit from.</p>
<pre><code class="lang-lua">    add_packages("protobuf-cpp", {public = true})
    add_files("src/**.proto", {proto_public = true})
</code></pre>
<p>Note: Since the headers generated by protobuf reference the headers of the protobuf-cpp package, we also need to mark the package headers as <code>{public = true}</code> to export it.</p>
<h2 id="cudaprogram">Cuda Program</h2>
<p>Create an empty project:</p>
<pre><code class="lang-bash">$ xmake create -P test -l cuda
$ cd test
$ xmake
</code></pre>
<pre><code class="lang-lua">-- define target
target("cuda_console")
    set_kind("binary")
    add_files("src/*.cu")
    -- generate SASS code for SM architecture of current host
    add_cugencodes("native")
    -- generate PTX code for the virtual architecture to guarantee compatibility
    add_cugencodes("compute_30")
</code></pre>
<p>!> Starting with v2.2.7, the default build will enable device-link. (see <a href="https://devblogs.nvidia.com/separate-compilation-linking-cuda-device-code/">Separate Compilation and Linking of CUDA C++ Device Code</a>)<br>If you want to disable device-link, you can set it with <code>set_policy("build.cuda.devlink", false)</code>.</p>
<p>!> Device functions in cuda source files should be device-linked once and only once. On targets with kind <code>binary</code> or <code>shared</code> xmake will automatically perform the device-link which takes the static libraries they depend into account, while for <code>static</code> targets by default will not be device-linked. However, if the final <code>binary</code> or <code>shared</code> target do not contain any cuda files, the device-link stage could be missing, resulting in an undefined reference error. In this case the static target should be set <code>add_values("cuda.build.devlink", true)</code> manually.</p>
<p>xmake will detect Cuda SDK automatically and we can also set the SDK directory (or SDK version for default installations) manually.</p>
<pre><code class="lang-bash">$ xmake f --cuda=/usr/local/cuda-9.1/
$ xmake f --cuda=9.1
$ xmake
</code></pre>
<p>If you want to known more information, you can see <a href="https://github.com/xmake-io/xmake/issues/158">#158</a>.</p>
<h2 id="lexyaccprogram">Lex &amp; Yacc Program</h2>
<pre><code class="lang-lua">target("calc")
     set_kind("binary")
     add_rules("lex", "yacc")
     add_files("src/*.l", "src/*.y")
</code></pre>
<h2 id="openmpprogram">OpenMP Program</h2>
<p>After v2.6.1, the configuration of openmp has been improved, which is more simplified and unified. We no longer need to configure additional rules. The same effect can be achieved only through a common openmp package.</p>
<pre><code class="lang-lua">add_requires("openmp")
target("loop")
     set_kind("binary")
     add_files("src/*.cpp")
     add_packages("openmp")
</code></pre>
<p>Before v2.5.9</p>
<pre><code class="lang-lua">add_requires("libomp", {optional = true})
target("loop")
    set_kind("binary")
    add_files("src/*.cpp")
    add_rules("c++.openmp")
    add_packages("libomp")
</code></pre>
<p>If it is c code, you need to enable ʻadd_rules("c.openmp")`. If it is c/c++ mixed compilation, then these two rules must be set.</p>
<h2 id="fortranprogram">Fortran Program</h2>
<p>After v2.3.6, the gfortran compiler is supported to compile fortran projects. We can quickly create an empty project based on fortran by using the following command:</p>
<p>After v2.3.8, xmake also supports Intel Fortran Compiler, you only need to switch the toolchain: <code>xmake f --toolchain=ifort</code></p>
<pre><code class="lang-bash">$ xmake create -l fortran -t console test
</code></pre>
<p>Its xmake.lua content is as follows:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("test")
    set_kind("binary")
    add_files("src/*.f90")
</code></pre>
<p>More code examples can be viewed here: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/fortran">Fortran Examples</a></p>
<h2 id="goprogram">Go Program</h2>
<p>xmake also supports the construction of go programs, and also provides command support for creating empty projects:</p>
<pre><code class="lang-bash">$ xmake create -l go -t console test
</code></pre>
<p>The content of xmake.lua is as follows:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("test")
    set_kind("binary")
    add_files("src/*.go")
</code></pre>
<p>In v2.3.6 version, xmake has made some improvements to its build support, and also supports cross compilation of go. For example, we can compile windows programs on macOS and linux:</p>
<pre><code class="lang-bash">$ xmake f -p windows -a x86
</code></pre>
<p>In addition, the new version also initially supports the third-party dependency package management of go:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

add_requires("go::github.com/sirupsen/logrus", {alias = "logrus"})
add_requires("go::golang.org/x/sys/internal/unsafeheader", {alias = "unsafeheader"})
if is_plat("windows") then
    add_requires("go::golang.org/x/sys/windows", {alias = "syshost"})
else
    add_requires("go::golang.org/x/sys/unix", {alias = "syshost"})
end

target("test")
    set_kind("binary")
    add_files("src/*.go")
    add_packages("logrus", "syshost", "unsafeheader")
</code></pre>
<p>However, there are still some imperfections. For example, all cascading dependency packages must be manually configured at present, which will be a bit more cumbersome and needs to be improved in the future.</p>
<p>For more examples, see: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/go">Go Examples</a></p>
<h2 id="dlangprogram">Dlang Program</h2>
<p>Create an empty project:</p>
<pre><code class="lang-bash">$ xmake create -l dlang -t console test
</code></pre>
<p>xmake.lua content:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("test")
    set_kind("binary")
    add_files("src/*.d")
</code></pre>
<p>Starting from the v2.3.6 version, xmake adds support for dub package management, which can quickly integrate third-party dependency packages of dlang:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

add_requires("dub::log 0.4.3", {alias = "log"})
add_requires("dub::dateparser", {alias = "dateparser"})
add_requires("dub::emsi_containers", {alias = "emsi_containers"})
add_requires("dub::stdx-allocator", {alias = "stdx-allocator"})
add_requires("dub::mir-core", {alias = "mir-core"})

target("test")
    set_kind("binary")
    add_files("src/*.d")
    add_packages("log", "dateparser", "emsi_containers", "stdx-allocator", "mir-core")
</code></pre>
<p>However, there are still some imperfections. For example, all cascading dependency packages must be manually configured at present, which will be a bit more cumbersome and needs to be improved in the future.</p>
<p>For more examples, see: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/dlang">Dlang Examples</a></p>
<h2 id="rustprogram">Rust Program</h2>
<p>Create an empty project:</p>
<pre><code class="lang-bash">$ xmake create -l rust -t console test
</code></pre>
<p>xmake.lua content:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("test")
    set_kind("binary")
    add_files("src/main.rs")
</code></pre>
<p>For more examples, see: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/rust">Rust Examples</a></p>
<h3 id="addcargopackagedependences">Add cargo package dependences</h3>
<p>example: <a href="https://github.com/xmake-io/xmake/tree/dev/tests/projects/rust/cargo_deps">https://github.com/xmake-io/xmake/tree/dev/tests/projects/rust/cargo_deps</a></p>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")
add_requires("cargo::base64 0.13.0")
add_requires("cargo::flate2 1.0.17", {configs = {features = "zlib"}})

target("test")
    set_kind("binary")
    add_files("src/main.rs")
    add_packages("cargo::base64", "cargo::flate2")
</code></pre>
<h3 id="integratingcargotomldependencypackages">Integrating Cargo.toml dependency packages</h3>
<p>Integrating dependencies directly using <code>add_requires("cargo::base64 0.13.0")</code> above has a problem.</p>
<p>If there are a lot of dependencies and several dependencies all depend on the same child dependencies, then there will be a redefinition problem, so if we use the full Cargo.toml to manage the dependencies we won&#39;t have this problem.</p>
<p>For example</p>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")
add_requires("cargo::test", {configs = {cargo_toml = path.join(os.projectdir(), "Cargo.toml")}})

target("test")
    set_kind("binary")
    add_files("src/main.rs")
    add_packages("cargo::test")
</code></pre>
<p>For a complete example see: <a href="https://github.com/xmake-io/xmake/blob/dev/tests/projects/rust/cargo_deps_with_toml/xmake.lua">cargo_deps_with_toml</a></p>
<h3 id="usecxxbridgetocallrustinc">Use cxxbridge to call rust in c++</h3>
<p>example: <a href="https://github.com/xmake-io/xmake/tree/dev/tests/projects/rust/cxx_call_rust_library">https://github.com/xmake-io/xmake/tree/dev/tests/projects/rust/cxx_call_rust_library</a></p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

add_requires("cargo::cxx 1.0")

target("foo")
    set_kind("static")
    add_files("src/foo.rs")
    set_values("rust.cratetype", "staticlib")
    add_packages("cargo::cxx")

target("test")
    set_kind("binary")
    add_rules("rust.cxxbridge")
    add_deps("foo")
    add_files("src/main.cc")
    add_files("src/bridge.rsx")
</code></pre>
<p>foo.rs</p>
<pre><code class="lang-rust">#[cxx::bridge]
mod foo {
    extern "Rust" {
        fn add(a: i32, b: i32) -> i32;
    }
}

pub fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
</code></pre>
<p>bridge interface file in c++, bridge.rsx</p>
<pre><code class="lang-rust">#[cxx::bridge]
mod foo {
    extern "Rust" {
        fn add(a: i32, b: i32) -> i32;
    }
}
</code></pre>
<p>main.cc</p>
<pre><code class="lang-c++">#include <stdio.h>
#include "bridge.rs.h"

int main(int argc, char** argv) {
    printf("add(1, 2) == %d\n", add(1, 2));
    return 0;
}
</code></pre>
<h3 id="callcinrust">Call c++ in rust</h3>
<p>example: <a href="https://github.com/xmake-io/xmake/tree/dev/tests/projects/rust/rust_call_cxx_library">https://github.com/xmake-io/xmake/tree/dev/tests/projects/rust/rust_call_cxx_library</a></p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("foo")
    set_kind("static")
    add_files("src/foo.cc")

target("test")
    set_kind("binary")
    add_deps("foo")
    add_files("src/main.rs")
</code></pre>
<p>main.rs</p>
<pre><code class="lang-rust">extern "C" {
    fn add(a: i32, b: i32) -> i32;
}

fn main() {
    unsafe {
        println!("add(1, 2) = {}", add(1, 2));
    }
}
</code></pre>
<p>foo.cc</p>
<pre><code class="lang-c++">extern "C" int add(int a, int b) {
    return a + b;
}
</code></pre>
<h2 id="swiftprogram">Swift Program</h2>
<p>Create an empty project:</p>
<pre><code class="lang-bash">$ xmake create -l swift -t console test
</code></pre>
<p>xmake.lua content:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("test")
    set_kind("binary")
    add_files("src/*.swift")
</code></pre>
<p>For more examples, see: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/swift">Swift Examples</a></p>
<h2 id="objcprogram">Objc Program</h2>
<p>Create an empty project:</p>
<pre><code class="lang-bash">$ xmake create -l objc -t console test
</code></pre>
<p>xmake.lua content:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("test")
    set_kind("binary")
    add_files("src/*.m")
</code></pre>
<p>For more examples, see: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/objc++">Objc Examples</a></p>
<h2 id="zigprogram">Zig Program</h2>
<p>Create an empty project:</p>
<pre><code class="lang-bash">$ xmake create -l zig -t console test
</code></pre>
<p>xmake.lua content:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("test")
     set_kind("binary")
     add_files("src/*.zig")
</code></pre>
<p>For more examples, see: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/zig">Zig Examples</a></p>
<h2 id="linuxbpfprogram">Linux Bpf Program</h2>
<p>Since 2.5.3, it supports bpf program construction, supports both linux and android platforms, and can automatically pull llvm and android ndk toolchains.</p>
<p>For more details, please see: <a href="https://github.com/xmake-io/xmake/issues/1274">#1274</a></p>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")
add_rules("platform.linux.bpf")

add_requires("linux-tools", {configs = {bpftool = true}})
add_requires("libbpf")
if is_plat("android") then
     add_requires("ndk >=22.x")
     set_toolchains("@ndk", {sdkver = "23"})
else
     add_requires("llvm >=10.x")
     set_toolchains("@llvm")
     add_requires("linux-headers")
end

target("minimal")
     set_kind("binary")
     add_files("src/*.c")
     add_packages("linux-tools", "linux-headers", "libbpf")
     set_license("GPL-2.0")
</code></pre>
<h2 id="valaprogram">Vala Program</h2>
<p>After 2.5.7 to support the construction of Vala programs, we need to apply the <code>add_rules("vala")</code> rule, and the glib package is necessary.</p>
<p>related issues: <a href="https://github.com/xmake-io/xmake/issues/1618">#1618</a></p>
<p><code>add_values("vala.packages")</code> is used to tell valac which packages the project needs, it will introduce the vala api of the relevant package, but the dependency integration of the package still needs to be downloaded and integrated through <code>add_requires("lua")</code>.</p>
<h3 id="consoleprogram">Console program</h3>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")

add_requires("lua", "glib")

target("test")
    set_kind("binary")
    add_rules("vala")
    add_files("src/*.vala")
    add_packages("lua", "glib")
    add_values("vala.packages", "lua")
</code></pre>
<h3 id="staticlibraryprogram">Static library program</h3>
<p>After v2.5.8, we continue to support the construction of library programs. The exported interface header file name can be set through <code>add_values("vala.header", "mymath.h")</code>, and through <code>add_values("vala.vapi", "mymath -1.0.vapi")</code> Set the name of the exported vapi file.</p>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")

add_requires("glib")

target("mymath")
    set_kind("static")
    add_rules("vala")
    add_files("src/mymath.vala")
    add_values("vala.header", "mymath.h")
    add_values("vala.vapi", "mymath-1.0.vapi")
    add_packages("glib")

target("test")
    set_kind("binary")
    add_deps("mymath")
    add_rules("vala")
    add_files("src/main.vala")
    add_packages("glib")
</code></pre>
<h3 id="dynamiclibraryprogram">Dynamic library program</h3>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")

add_requires("glib")

target("mymath")
    set_kind("shared")
    add_rules("vala")
    add_files("src/mymath.vala")
    add_values("vala.header", "mymath.h")
    add_values("vala.vapi", "mymath-1.0.vapi")
    add_packages("glib")

target("test")
    set_kind("binary")
    add_deps("mymath")
    add_rules("vala")
    add_files("src/main.vala")
    add_packages("glib")
</code></pre>
<p>More examples: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/vala">Vala examples</a></p>
<h2 id="pascalprogram">Pascal Program</h2>
<p>After 2.5.8, we can support the construction of Pascal programs. For related issues, see: <a href="https://github.com/xmake-io/xmake/issues/388">#388</a></p>
<h3 id="consoleprogram">Console Program</h3>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")
target("test")
     set_kind("binary")
     add_files("src/*.pas")
</code></pre>
<h3 id="dynamiclibraryprogram">Dynamic library program</h3>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")
target("foo")
     set_kind("shared")
     add_files("src/foo.pas")

target("test")
     set_kind("binary")
     add_deps("foo")
     add_files("src/main.pas")
</code></pre>
<p>More examples: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/pascal">Pascal examples</a></p>
<h2 id="swigmodule">Swig module</h2>
<p>Version 2.5.8 supports the construction of Swig modules. We provide <code>swig.c</code> and <code>swig.cpp</code> rules, which respectively support the generation of c/c++ module interface code, and cooperate with xmake&#39;s package management system to realize fully automated modules and dependent packages. Integration.</p>
<p>Related issues: <a href="https://github.com/xmake-io/xmake/issues/1622">#1622</a></p>
<h3 id="luacmodule">Lua/C module</h3>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")
add_requires("lua")

target("example")
    add_rules("swig.c", {moduletype = "lua"})
    add_files("src/example.i", {swigflags = "-no-old-metatable-bindings"})
    add_files("src/example.c")
    add_packages("lua")
</code></pre>
<h3 id="pythoncmodule">Python/C module</h3>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")
add_requires("python 3.x")

target("example")
    add_rules("swig.c", {moduletype = "python"})
    add_files("src/example.i", {scriptdir = "share"})
    add_files("src/example.c")
    add_packages("python")
</code></pre>
<h3 id="pythoncmodule">Python/C++ module</h3>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")
add_requires("python 3.x")

target("example")
    add_rules("swig.cpp", {moduletype = "python"})
    add_files("src/example.i", {scriptdir = "share"})
    add_files("src/example.cpp")
    add_packages("python")
</code></pre>
<h3 id="javacmodule">Java/C module</h3>
<p><a href="https://github.com/xmake-io/xmake/blob/dev/tests/projects/swig/java_c">Example project</a></p>
<pre><code class="lang-lua">-- make sure you config to an enviroment with jni.h
-- for example: xmake f -c -p android

target("example")
    set_kind(&#39;shared&#39;)
    -- set moduletype to java
    add_rules("swig.c", {moduletype = "java"})
    -- test jar build
    -- add_rules("swig.c", {moduletype = "java" , buildjar = true})
    -- use swigflags to provider package name and output path of java files
    add_files("src/example.i", {swigflags = {
        "-package",
        "com.example",
        "-outdir",
        "build/java/com/example/"
    }})
    add_files("src/example.c")
    add_includedirs("src")
    before_build(function()
        -- ensure output path exists before running swig
        os.mkdir("build/java/com/example/")
    end)
</code></pre>
<p>We can also configure <code>buildjar = true</code> to build jar file.</p>
<pre><code class="lang-lua">add_rules("swig.c", {moduletype = "java", buildjar = true})
</code></pre>
<h2 id="c20module">C++20 Module</h2>
<h3 id="quickstart">Quick Start</h3>
<p>xmake uses <code>.mpp</code> as the default module extension, but also supports <code>.ixx</code>, <code>.cppm</code>, <code>.mxx</code> and other extensions.</p>
<p>At present, xmake has fully supported the C++20 Modules construction support of gcc11/clang/msvc,<br>and can automatically analyze the dependencies between modules to maximize parallel compilation.</p>
<pre><code class="lang-lua">set_languages("c++20")
target("class")
    set_kind("binary")
    add_files("src/*.cpp", "src/*.mpp")
</code></pre>
<p>For more examples, see: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/c%2B%2B/modules">C++ Modules</a></p>
<h3 id="cpponlyproject">Cpp-only project</h3>
<p>The v2.7.1 release has refactored and upgraded the C++20 module implementation to include support for Headerunits,<br>which allows us to introduce Stl and user header modules into the module.</p>
<p>The relevant patch is available at: <a href="https://github.com/xmake-io/xmake/pull/2641">#2641</a>.</p>
<p>Note: Normally we need to add at least one <code>.mpp</code> file to enable C++20 modules compilation, if we only have a cpp file, module compilation will not be enabled by default.</p>
<p>However, if we just want to use the module&#39;s Headerunits feature in the cpp file, e.g. by introducing some stl Headerunits into the cpp, then we can also set <code>set_policy</code> to <code>.mpp</code>.<br>then we can also force C++ Modules compilation by setting <code>set_policy("build.c++.modules", true)</code>, for example:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("test")
    set_kind("binary")
    add_files("src/*.cpp")
    set_languages("c++20")
    set_policy("build.c++.modules", true)
</code></pre>
<h3 id="cmoduledistribution">C++ Module distribution</h3>
<p>Many thanks to <a href="https://github.com/Arthapz">Arthapz</a> for continuing to help improve xmake&#39;s support for C++ Modules in this new release.</p>
<p>We can now distribute C++ Modules as packages for quick integration and reuse in other projects.</p>
<p>This is a prototype implementation based on the draft design for module distribution in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2473r1.pdf">p2473r1</a>.</p>
<h4 id="creatingacmodulespackagefordistribution">Creating a C++ Modules package for distribution</h4>
<p>We start by maintaining a build of the modules using xmake.lua and telling xmake which module files to install for external distribution by specifying <code></code>{install = true}`&#39;&#39;.</p>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")
set_languages("c++20")

target("foo")
    set_kind("static")
    add_files("*.cpp")
    add_files("*.mpp", { install = true })
</code></pre>
<p>We then make it into a package that we can commit to the <a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a> repository, or of course directly into a local package, or a private repository package.</p>
<p>Here, for testing purposes, we just make it a local package via <code>set_sourcedir</code>.</p>
<pre><code class="lang-lua">package("foo")
    set_sourcedir(path.join(os.scriptdir(), "src"))
    on_install(function(package)
        import("package.tools.xmake").install(package, {})
    end)
`
</code></pre>
<h4 id="integratingthecmodulespackage">Integrating the C++ Modules package</h4>
<p>We then quickly integrate the C++ Modules package for use via the package integration interface with <code>add_requires("foo")</code>.</p>
<p>Since the modules packages for foo are defined in a private repository, we introduce our own package repository via <code>add_repositories("my-repo my-repo")</code>.</p>
<p>If the package has already been committed to the official xmake-repo repository, there is no need to configure it additionally.</p>
<pre><code class="lang-lua">add_rules("mode.release", "mode.debug")
set_languages("c++20")

add_repositories("my-repo my-repo")
add_requires("foo", "bar")

target("packages")
    set_kind("binary")
    add_files("src/*.cpp")
    add_packages("foo", "bar")
    set_policy("build.c++.modules", true)
</code></pre>
<p>Once the packages are integrated, we can run the <code></code>xmake`&#39;&#39; command to download, compile and integrate the C++ Modules package for use with one click.</p>
<pre><code class="lang-bash">$ xmake
checking for platform ... linux
checking for architecture ... x86_64
note: install or modify (m) these packages (pass -y to skip confirm)?
in my-repo:
  -> foo latest
  -> bar latest
please input: y (y/n/m)

  => install bar latest ... ok
  => install foo latest ... ok
[ 0%]: generating.module.deps src/main.cpp
[ 0%]: generating.module.deps /mnt/xmake/tests/projects/c++/modules/packages/build/.packages/b/bar/latest/ 4e0143c97b65425b855ad5fd03038b6a/modules/bar/bar.mpp
[ 0%]: generating.module.deps /mnt/xmake/tests/projects/c++/modules/packages/build/.packages/f/foo/latest/ 4e0143c97b65425b855ad5fd03038b6a/modules/foo/foo.mpp
[ 14%]: compiling.module.release bar
[ 14%]: compiling.module.release foo
[ 57%]: compiling.release src/main.cpp
[ 71%]: linking.release packages
[ 100%]: build ok!
```&#39;&#39;

Note: After each package is installed, a meta-info file for the maintenance module is stored in the package path, this is a format specification agreed in ``p2473r1.pdf``, it may not be the final standard, but this does not affect our ability to use the distribution of the module now.

```bash
$ cat . /build/.packages/f/f/foo/latest/4e0143c97b65425b855ad5fd03038b6a/modules/foo/foo.mpp.meta-info
{"_VENDOR_extension":{"xmake":{"name": "foo", "file": "foo.mpp"}}, "definitions":{}, "include_paths":{}}
</code></pre>
<p>The full example project is available at: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/c%2B%2B/modules/packages">C++ Modules package distribution example project</a></p>
<h3 id="supportforc23stdmodules">Support for C++23 Std Modules</h3>
<p><a href="https://github.com/Arthapz">Arthapz</a> has also helped to improve support for C++23 Std Modules.</p>
<p>It is currently supported by three compilers in progress.</p>
<h4 id="msvc">Msvc</h4>
<p>The latest Visual Studio 17.5 preview already supports it, and the non-standard ifc std modules will be deprecated.</p>
<p>For the standard C++23 std modules, this is how we introduced them.</p>
<pre><code class="lang-c">import std;
</code></pre>
<p>Whereas for ifc std modules, we need to write it like this.</p>
<pre><code>import std.core;
</code></pre><p>This is not a C++23 standard, it is only provided by msvc, it is not compatible with other compilers and will be deprecated in new versions of msvc.<br>Therefore the new version of Xmake will only support C++23 std modules and not the deprecated ifc std modules.</p>
<h4 id="clang">Clang</h4>
<p>It seems that the latest clang does not yet fully support C++23 std modules either, and is still in draft patch status, <a href="https://reviews.llvm.org/D135507">#D135507</a>.</p>
<p>However, Xmake does support it, so if you want to try it out, you can merge in the patch and test it with xmake.</p>
<p>There is also experimental support for non-standard std modules in lower versions of clang.</p>
<p>It is still possible to experiment with xmake to build std modules in lower versions of clang, even though it is probably still a toy (and will encounter many problems).</p>
<p>For a discussion see: <a href="https://github.com/xmake-io/xmake/pull/3255">#3255</a></p>
<h4 id="gcc">Gcc</h4>
<p>It is not currently supported.</p>
<h2 id="mergestaticlibraries">Merge static libraries</h2>
<h3 id="automaticallymergetargetlibraries">Automatically merge target libraries</h3>
<p>After 2.5.8, we can enable automatic merging of all dependent static libraries by setting the <code>build.merge_archive</code> strategy, for example:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("add")
    set_kind("static")
    add_files("src/add.c")
    add_files("src/subdir/add.c")

target("sub")
    set_kind("static")
    add_files("src/sub.c")
    add_files("src/subdir/sub.c")

target("mul")
    set_kind("static")
    add_deps("add", "sub")
    add_files("src/mul.c")
    set_policy("build.merge_archive", true)
</code></pre>
<p>The mul static library automatically merges the add and sub static libraries to generate a complete libmul.a library containing add/sub code.</p>
<p>This merge is relatively stable and complete, supports ar and msvc/lib.exe, also supports the merge of static libraries generated by the cross-compilation tool chain, and also supports static libraries with the same name obj file.</p>
<h3 id="mergespecifiedstaticlibraryfiles">Merge specified static library files</h3>
<p>If the automatic merge does not meet the requirements, we can also actively call the <code>utils.archive.merge_archive</code> module to merge the specified static library list in the <code>after_link</code> stage.</p>
<pre><code class="lang-lua">target("test")
    after_link(function (target)
        import("utils.archive.merge_staticlib")
        merge_staticlib(target, "libout.a", {"libfoo.a", "libbar.a"})
    end)
</code></pre>
<h3 id="useadd_filestomergestaticlibraries">Use add_files to merge static libraries</h3>
<p>In fact, our previous version already supports merging static libraries through <code>add_files("*.a")</code>.</p>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("*.a")
    add_files("*.c")
</code></pre>
<p>However, it has some drawbacks: if you use ar, there may be conflicts with the same name of the .obj object file and cause the merge to fail. Therefore, it is recommended to use the merge method described above, which is more stable, reliable, and simpler.</p>
<p>Related issues: <a href="https://github.com/xmake-io/xmake/issues/1638">#1638</a></p>
<h2 id="nimprogram">Nim Program</h2>
<p>After v2.5.9, we have added support for the Nimlang project. For related issues, see: <a href="https://github.com/xmake-io/xmake/issues/1756">#1756</a></p>
<h3 id="createanemptyproject">Create an empty project</h3>
<p>We can use the <code>xmake create</code> command to create an empty project.</p>
<pre><code class="lang-bash">xmake create -l nim -t console test
xmake create -l nim -t static test
xmake create -l nim -t shared test
</code></pre>
<h3 id="consoleprogram">Console Program</h3>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("test")
    set_kind("binary")
    add_files("src/main.nim")
</code></pre>
<pre><code class="lang-bash">$ xmake -v
[33%]: linking.release test
/usr/local/bin/nim c --opt:speed --nimcache:build/.gens/test/macosx/x86_64/release/nimcache -o:b
uild/macosx/x86_64/release/test src/main.nim
[100%]: build ok!
</code></pre>
<h3 id="staticlibraryprogram">Static library program</h3>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("foo")
    set_kind("static")
    add_files("src/foo.nim")

target("test")
    set_kind("binary")
    add_deps("foo")
    add_files("src/main.nim")
</code></pre>
<pre><code class="lang-bash">$ xmake -v
[33%]: linking.release libfoo.a
/usr/local/bin/nim c --opt:speed --nimcache:build/.gens/foo/macosx/x86_64/release/nimcache --app
:staticlib --noMain --passC:-DNimMain=NimMain_B6D5BD02 --passC:-DNimMainInner=NimMainInner_B6D5B
D02 --passC:-DNimMainModule=NimMainModule_B6D5BD02 --passC:-DPreMain=PreMain_B6D5BD02 --passC:-D
PreMainInner=PreMainInner_B6D5BD02 -o:build/macosx/x86_64/release/libfoo.a src/foo.nim
[66%]: linking.release test
/usr/local/bin/nim c --opt:speed --nimcache:build/.gens/test/macosx/x86_64/release/nimcache --pa
ssL:-Lbuild/macosx/x86_64/release --passL:-lfoo -o:build/macosx/x86_64/release/test src/main.nim
[100%]: build ok!
</code></pre>
<h3 id="dynamiclibraryprogram">Dynamic library program</h3>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("foo")
    set_kind("shared")
    add_files("src/foo.nim")

target("test")
    set_kind("binary")
    add_deps("foo")
    add_files("src/main.nim")
</code></pre>
<pre><code class="lang-bash">$ xmake -rv
[33%]: linking.release libfoo.dylib
/usr/local/bin/nim c --opt:speed --nimcache:build/.gens/foo/macosx/x86_64/release/nimcache --app
:lib --noMain -o:build/macosx/x86_64/release/libfoo.dylib src/foo.nim
[66%]: linking.release test
/usr/local/bin/nim c --opt:speed --nimcache:build/.gens/test/macosx/x86_64/release/nimcache --pa
ssL:-Lbuild/macosx/x86_64/release --passL:-lfoo -o:build/macosx/x86_64/release/test src/main.nim
[100%]: build ok!
</code></pre>
<h3 id="ccodemixedcompilation">C code mixed compilation</h3>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("foo")
    set_kind("static")
    add_files("src/*.c")

target("test")
    set_kind("binary")
    add_deps("foo")
    add_files("src/main.nim")
</code></pre>
<h3 id="nimbledependencypackageintegration">Nimble dependency package integration</h3>
<p>For a complete example, see: <a href="https://github.com/xmake-io/xmake/tree/dev/tests/projects/nim/nimble_package">Nimble Package Example</a></p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

add_requires("nimble::zip >0.3")

target("test")
    set_kind("binary")
    add_files("src/main.nim")
    add_packages("nimble::zip")
</code></pre>
<p>main.nim</p>
<pre><code class="lang-nim">import zip/zlib

echo zlibVersion()
</code></pre>
<h3 id="nativedependencypackageintegration">Native dependency package integration</h3>
<p>For a complete example, see: <a href="https://github.com/xmake-io/xmake/tree/dev/tests/projects/nim/native_package">Native Package Example</a></p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

add_requires("zlib")

target("test")
    set_kind("binary")
    add_files("src/main.nim")
    add_packages("zlib")
</code></pre>
<p>main.nim</p>
<pre><code class="lang-nim">proc zlibVersion(): cstring {.cdecl, importc}

echo zlibVersion()
</code></pre>
<h2 id="keilmdkembeddedprogram">Keil/MDK Embedded Program</h2>
<p>Related example project: <a href="https://github.com/xmake-io/xmake/tree/dev/tests/projects/embed/mdk/hello">Example</a></p>
<p>xmake will automatically detect the compiler installed by Keil/MDK, related issues <a href="https://github.com/xmake-io/xmake/issues/1753">#1753</a>.</p>
<p>Compile with armcc</p>
<pre><code class="lang-bash">$ xmake f -p cross -a cortex-m3 --toolchain=armcc -c
$ xmake
</code></pre>
<p>Compile with armclang</p>
<pre><code class="lang-bash">$ xmake f -p cross -a cortex-m3 --toolchain=armclang -c
$ xmake
</code></pre>
<h3 id="executableprogram">Executable program</h3>
<pre><code class="lang-lua">target("hello")
     add_deps("foo")
     add_rules("mdk.console")
     add_files("src/*.c", "src/*.s")
     add_includedirs("src/lib/cmsis")
     set_runtimes("microlib")
</code></pre>
<p>It should be noted that when some mdk programs all use the microlib library to run, it requires the compiler to add the <code>__MICROLIB</code> macro definition, and the linker to add various configurations such as <code>--library_type=microlib</code>.</p>
<p>We can set directly to the microlib runtime library through <code>set_runtimes("microlib")</code>, and all relevant options can be set automatically.</p>
<h3 id="staticlibraryprogram">Static library program</h3>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

target("foo")
     add_rules("mdk.static")
     add_files("src/foo/*.c")
     set_runtimes("microlib")
</code></pre>
<h2 id="keilc51embeddedprograms">Keil/C51 embedded programs</h2>
<h3 id="executableprograms">Executable programs</h3>
<pre><code class="lang-lua">target("hello")
    add_rules("c51.binary")
    set_toolchains("c51")
    add_files("src/main.c")
</code></pre>
<h2 id="linuxkerneldrivermodule">Linux kernel driver module</h2>
<p>In version v2.6.2, xmake fully supports the construction of Linux kernel driver modules. This may be the first and only third-party build tool that supports compiling Linux kernel drivers.</p>
<h3 id="helloworldmodule">Hello world module</h3>
<p>Full example: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/linux/driver/hello">Linux Kernel Driver Modules</a></p>
<p>Its configuration is very simple. You only need to configure the linux-headers package that supports the module, and then apply the <code>platform.linux.module</code> build rule.</p>
<pre><code class="lang-lua">add_requires("linux-headers", {configs = {driver_modules = true}})

target("hello")
    add_rules("platform.linux.module")
    add_files("src/*.c")
    add_packages("linux-headers")
    set_license("GPL-2.0")
</code></pre>
<p>Then directly execute the xmake command, compile with one key, and generate the kernel driver module hello.ko.</p>
<pre><code class="lang-bash">$ xmake
[20%]: cache compiling.release src/add.c
[20%]: cache compiling.release src/hello.c
[60%]: linking.release build/linux/x86_64/release/hello.ko
[100%]: build ok!
</code></pre>
<p>We can also look at the complete build command parameters.</p>
<pre><code class="lang-bash">$ xmake -v
[20%]: cache compiling.release src/add.c
/usr/bin/ccache /usr/bin/gcc -c -m64 -O2 -std=gnu89 -I/usr/src/linux-headers-5.11.0-41-generic/arch/x86/include -I/usr /src/linux-headers-5.11.0-41-generic/arch/x86/include/generated -I/usr/src/linux-headers-5.11.0-41-generic/include -I/usr/src/linux -headers-5.11.0-41-generic/arch/x86/include/uapi -I/usr/src/linux-headers-5.11.0-41-generic/arch/x86/include/generated/uapi -I/usr /src/linux-headers-5.11.0-41-generic/include/uapi -I/usr/src/linux-headers-5.11.0-41-generic/include/generated/uapi -D__KERNEL__ -DMODULE -DKBUILD_MODNAME=\ "hello\" -DCONFIG_X86_X32_ABI -isystem /usr/lib/gcc/x86_64-linux-gnu/10/include -include /usr/src/linux-headers-5.11.0-41-generic/include/linux/kconfig.h -include /usr/src/linux-headers-5.11.0-41-generic/include/linux/compiler_types.h -nostdinc -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -mno -80387 -mno-fp-ret-in-387 -mpreferred-stack-boundary=3 -mskip-rax-setup -mtune=generic -mno-red-zone -mcmodel=kernel -mindirect-branch=thunk-extern -mindirect -branch-re gister -mrecord-mcount -fmacro-prefix-map=./= -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -fcf-protection=none -falign-jumps=1 -falign-loops= 1 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-delete-null-pointer-checks -fno-allow-store-data-races -fno-reorder-blocks -fno-ipa-cp-clone- fno-partial-inlining -fstack-protector-strong -fno-inline-functions-called-once -falign-functions=32 -fno-strict-overflow -fno-stack-check -fconserve-stack -DKBUILD_BASENAME=\"add\ "-o build/.objs/hello/linux/x86_64/release/src/add.co src/add.c
[20%]: cache compiling.release src/hello.c
/usr/bin/ccache /usr/bin/gcc -c -m64 -O2 -std=gnu89 -I/usr/src/linux-headers-5.11.0-41-generic/arch/x86/include -I/usr /src/linux-headers-5.11.0-41-generic/arch/x86/include/generated -I/usr/src/linux-headers-5.11.0-41-generic/include -I/usr/src/linux -headers-5.11.0-41-generic/arch/x86/include/uapi -I/usr/src/linux-headers-5.11.0-41-generic/arch/x86/include/generated/uapi -I/usr /src/linux-headers-5.11.0-41-generic/include/uapi -I/usr/src/linux-headers-5.11.0-41-generic/include/generated/uapi -D__KERNEL__ -DMODULE -DKBUILD_MODNAME=\ "hello\" -DCONFIG_X86_X32_ABI -isystem /usr/lib/gcc/x86_64-linux-gnu/10/include -include /usr/src/linux-headers-5.11.0-41-generic/include/linux/kconfig.h -include /usr/src/linux-headers-5.11.0-41-generic/include/linux/compiler_types.h -nostdinc -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -mno -80387 -mno-fp-ret-in-387 -mpreferred-stack-boundary=3 -mskip-rax-setup -mtune=generic -mno-red-zone -mcmodel=kernel -mindirect-branch=thunk-extern -mindirect -branch-re gister -mrecord-mcount -fmacro-prefix-map=./= -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -fcf-protection=none -falign-jumps=1 -falign-loops= 1 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-delete-null-pointer-checks -fno-allow-store-data-races -fno-reorder-blocks -fno-ipa-cp-clone- fno-partial-inlining -fstack-protector-strong -fno-inline-functions-called-once -falign-functions=32 -fno-strict-overflow -fno-stack-check -fconserve-stack -DKBUILD_BASENAME=\"hello\ "-o build/.objs/hello/linux/x86_64/release/src/hello.co src/hello.c
[60%]: linking.release build/linux/x86_64/release/hello.ko
/usr/bin/ld -m elf_x86_64 -r -o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.o build/.objs/hello/linux/x86_64/ release/src/add.co build/.objs/hello/linux/x86_64/release/src/hello.co
/usr/src/linux-headers-5.11.0-41-generic/scripts/mod/modpost -m -a -o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/Module .symvers -e -N -T-
WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped.
/usr/bin/ccache /usr/bin/gcc -c -m64 -O2 -std=gnu89 -I/usr/src/linux-headers-5.11.0-41-generic/arch/x86/include -I/usr /src/linux-headers-5.11.0-41-generic/arch/x86/include/generated -I/usr/src/linux-headers-5.11.0-41-generic/include -I/usr/src/linux -headers-5.11.0-41-generic/arch/x86/include/uapi -I/usr/src/linux-headers-5.11.0-41-generic/arch/x86/include/generated/uapi -I/usr /src/linux-headers-5.11.0-41-generic/include/uapi -I/usr/src/linux-headers-5.11.0-41-generic/include/generated/uapi -D__KERNEL__ -DMODULE -DKBUILD_MODNAME=\"hello\" -DCONFIG_X86_X32_ABI -isystem /usr/lib/gcc/x86_64-linux-gnu/10/include -include /usr/src/linux-headers- 5.11.0-41-generic/include/linux/kconfig.h -include /usr/src/linux-headers-5.11.0-41-generic/include/linux/compiler_types.h -nostdinc -mno-sse -mno- mmx -mno-sse2 -mno-3dnow -mno-avx -mno-80387 -mno-fp-ret-in-387 -mpreferred-stack-boundary=3 -mskip-rax-setup -mtune=generic -mno-red- zone -mcmodel=kernel -mindirect-branch=thunk-extern -mindirect-branch-register -mrecord-mcount -fmacro-prefix-map=./= -fno-strict-aliasing -fno-common -fshort-wchar -fno- PIE -fcf-protection=none -falign-jumps=1 -falign-loops=1 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-delete-null-pointer-checks -fno-allow-store- data-races -fno-reorder-blocks -fno-ipa-cp-clone -fno-partial-inlining -fstack-protector-strong -fno-inline-functions-called-once -falign-functions=32 -fno-strict- overflow -fno-stack-check -fconserve-stack -o build/.o bjs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko. mod.c
/usr/bin/ld -m elf_x86_64 -r --build-id=sha1 -T /usr/src/linux-headers-5.11.0-41-generic/scripts/module.lds -o build/linux/x86_64/ release/hello.ko build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/ release/hello.ko.mod.o

</code></pre>
<p>Through the <code>add_requires("linux-headers", {configs = {driver_modules = true}})</code> configuration package, xmake will automatically find the corresponding linux-headers package from the system first.</p>
<p>If it is not found, xmake will also automatically download it, and then automatically configure and build the kernel source code with driver modules, and use it to continue building the kernel module.</p>
<h3 id="customlinuxheaderspath">Custom linux-headers path</h3>
<p>Since the release of v2.6.2, there have been many feedbacks from users. In most cases, the linux kernel driver is built based on a customized version of the linux kernel, so it is necessary to be able to customize the configuration of the linux-headers path instead of using the remote dependency package mode.</p>
<p>In fact, we can do this by rewriting the linux-headers package ourselves.</p>
<pre><code class="lang-lua">package("linux-headers")
    on_fetch(function (package, opt)
        return {includedirs = "/usr/src/linux-headers-5.0/include"}
    end)
package_end()

add_requires("linux-headers")

target("test")
    add_rules("platform.linux.module")
    add_files("src/*.c")
    add_packages("linux-headers")
</code></pre>
<p>But this may be a bit cumbersome, so in v2.6.3, we support more convenient setting of the linux-headers path.</p>
<pre><code class="lang-lua">target("hello")
    add_rules("platform.linux.module")
    add_files("src/*.c")
    set_values("linux.driver.linux-headers", "/usr/src/linux-headers-5.11.0-41-generic")
</code></pre>
<p>We can also pass in the linux-headers path as <code>xmake f --linux-headers=/usr/src/linux-headers</code> by defining option options.</p>
<pre><code class="lang-lua">option("linux-headers", {showmenu = true, description = "Set linux-headers path."})
target("hello")
    add_rules("platform.linux.module")
    add_files("src/*.c")
    set_values("linux.driver.linux-headers", "$(linux-headers)")
</code></pre>
<p>For more details, please see: <a href="https://github.com/xmake-io/xmake/issues/1923">#1923</a></p>
<h3 id="crosscompilation">Cross compilation</h3>
<p>We also support cross-compilation of kernel driver modules, such as using cross-compilation tool chain on Linux x86_64 to build Linux Arm/Arm64 driver modules.</p>
<p>We only need to prepare our own cross-compilation tool chain, specify its root directory through <code>--sdk=</code>, then switch to the <code>-p cross</code> platform configuration, and finally specify the architecture arm/arm64 to be built.</p>
<p>The cross toolchain used here can be downloaded from here: <a href="https://releases.linaro.org/components/toolchain/binaries/latest-7/aarch64-linux-gnu/">Download toolchains</a></p>
<p>For more, cross-compilation configuration documents, see: <a href="/mirror/guide/configuration.html#common-cross-compilation-configuration">Configure cross-compilation</a></p>
<p>!> Currently only supports arm/arm64 cross-compilation architecture, and more platform architectures will be supported in the future.</p>
<h4 id="buildarmdrivermodule">Build Arm driver module</h4>
<pre><code class="lang-bash">$ xmake f -p cross -a arm --sdk=/mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf -c
$ xmake -v
checking for arm-linux-gnueabihf-g++ ... /mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-g++
checking for the linker (ld) ... arm-linux-gnueabihf-g++
checking for /mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-g++ ... ok
checking for flags (-fPIC) ... ok
checking for /mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc ... ok
checking for flags (-fPIC) ... ok
checking for flags (-O2) ... ok
checking for ccache ... /usr/bin/ccache
[20%]: cache compiling.release src/add.c
/usr/bin/ccache /mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc -c -O2 -std=gnu89 -I/home/ruki/. xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include /generated -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805 /arch/arm/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi -I/home/ruki/.xmake /packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi -D__KERNEL__ DMODULE -DKBUILD_MODNAME=\"hello\" -D__LINUX_ARM_ARCH__=6 -isystem /mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf /bin/../lib/gcc/arm-linux-gnueabihf/7.5.0/include -include /home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig .h -include /home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h -nostdinc -fno-strict-aliasing -fno-common -fshort-wchar- fno-PIE -falign-jumps=1 -falign-loops=1 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-delete-null-pointer-checks -fno-reorder-blocks -fno-ipa- cp-clone -fno-partial-inlining -fstack-protector-strong -fno-inline-functions-called-once -falign-functions=32 -fno-strict-overflow -fno-stack-check -fconserve-stack -mbig- endian -mabi=aapcs-linux -mfpu=vfp -marm -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -DKBUILD_BASENAME=\"add\" -o build/.objs/hello/cross/arm/ release/src/add.co src/add.c
[20%]: cache compiling.release src/hello.c
/usr/bin/ccache /mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc -c -O2 -std=gnu89 -I/home/ruki/. xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/ 7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi -I/home/ruki/. xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi -D__KERNEL__ -DMODULE -DKBUILD_MODNAME=\"hello\" -D__LINUX_ARM_ARCH__=6 -isystem /mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/ 7.5.0/include -include /home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h -include /home/ruki/.xmake/packages/l/ linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h -nostdinc -fno-strict-alia sing -fno-common -fshort-wchar -fno-PIE -falign-jumps=1 -falign-loops=1 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-delete-null-pointer-checks- fno-reorder-blocks -fno-ipa-cp-clone -fno-partial-inlining -fstack-protector-strong -fno-inline-functions-called-once -falign-functions=32 -fno-strict-overflow -fno- stack-check -fconserve-stack -mbig-endian -mabi=aapcs-linux -mfpu=vfp -marm -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -DKBUILD_BASENAME=\"hello\" -o build /.objs/hello/cross/arm/release/src/hello.co src/hello.c
checking for flags (-MMD -MF) ... ok
checking for flags (-fdiagnostics-color=always) ... ok
[60%]: linking.release build/cross/arm/release/hello.ko
/mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-ld -EB -r -o build/.objs/hello/cross/arm/release/build/cross /arm/release/hello.ko.o build/.objs/hello/cross/arm/release/src/add.co build/.objs/hello/cross/arm/release/src/hello.co
/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/scripts/mod/modpost -m -a -o build/.objs/hello/cross/arm/release/build/cross/ arm/release/Module.symvers -e -N -T-
WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped.
/usr/bin/ccache /mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc -c -O2 -std=gnu89 -I/home/ruki/. xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include /generated -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805 /arch/arm/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi -I/home/ruki/.xmake /packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi -D__KERNEL__ DMODULE -DKBUILD_MODNAME=\"hello\" -D__LINUX_ARM_ARCH__=6 -isystem /mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf /bin/../lib/gcc/arm-linux-gnueabihf/7.5.0/include -include /home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig .h -include /home/ruki/.xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h -nostdinc -fno-strict-aliasing -fno-common -fshort-wchar- fno-PIE -falign-jumps=1 -falign-loops=1 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-delete-null-pointer-checks -fno-reorder-blocks -fno-ipa- cp-clone -fno-partial-inlining -fstack-protector-strong -fno-inline-functions-called-once -falign-functions=32 -fno-strict-overflow -fno-stack-check -fconserve-stack -mbig- endian -mabi=aapcs-linux -mfpu=vfp -marm -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -o build/.objs/hello/cross/arm/release/build/cross/arm/ release/hello.ko.mod.o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.c
/mnt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-ld -EB --be8 -r --build-id=sha1 -T /home/ruki/. xmake/packages/l/linux-headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/scripts/module.lds -o build/cross/arm/release/hello.ko build/.objs/hello/cross/arm/release/build/cross /arm/release/hello.ko.o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.o
[100%]: build ok!

</code></pre>
<h4 id="buildarm64drivermodule">Build Arm64 driver module</h4>
<pre><code class="lang-bash">$ xmake f -p cross -a arm64 --sdk=/mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu -c
checking for aarch64-linux-gnu-g++ ... /mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-g++
checking for the linker (ld) ... aarch64-linux-gnu-g++
checking for /mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-g++ ... ok
checking for flags (-fPIC) ... ok
checking for /mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc ... ok
checking for flags (-fPIC) ... ok
checking for flags (-O2) ... ok
checking for ccache ... /usr/bin/ccache
[20%]: cache compiling.release src/add.c
/usr/bin/ccache /mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc -c -O2 -std=gnu89 -I/home/ruki/. xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include /generated -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de /arch/arm64/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi -I/home/ruki/.xmake /packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi -D__KERNEL__- DMODULE -DKBUILD_MODNAME=\"hello\" -isystem /mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/../lib/gcc/aarch 64-linux-gnu/7.5.0/include -include /home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h -include /home/ruki/. xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h -nostdinc -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -falign-jumps=1- falign-loops=1 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-delete-null-pointer-checks -fno-reorder-blocks -fno-ipa-cp-clone -fno-partial-inlining- fstack-protector-strong -fno-inline-functions-called-once -falign-functions=32 -fno-strict-overflow -fno-stack-check -fconserve-stack -DKBUILD_BASENAME=\"add\" -o build/. objs/hello/cross/arm64/release/src/add.co src/add.c
[20%]: cache compiling.release src/hello.c
/usr/bin/ccache /mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc -c -O2 -std=gnu89 -I/home/ruki/. xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include /generated -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de /arch/arm64/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi -I/home/ruki/.xmake /packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi -D__KERNEL__- DMODULE -DKBUILD_MODNAME=\"hello\" -isystem /mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/../lib/gcc/aarch 64-linux-gnu/7.5.0/include -include /home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h -include /home/ruki/. xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h -nostdinc -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -falign-jumps=1- falign-loops=1 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-delete-null-pointer-checks -fno-reorder-blocks -fno-ipa-cp-clone -fno-partial-inlining- fstack-protector-strong -fno-inline-functions-called-once -falign-functions=32 -fno-strict-overflow -fno-stack-check -fconserve-stack -DKBUILD_BASENAME=\"hello\" -o build/. objs/hello/cross/arm64/release/src/hello.co src/hello.c
checking for flags (-MMD -MF) ... ok
checking for flags (-fdiagnostics-color=always) ... ok
[60%]: linking.release build/cross/arm64/release/hello.ko
/mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-ld -EL -maarch64elf -r -o build/.objs/hello/cross/arm64/release/build /cross/arm64/release/hello.ko.o build/.objs/hello/cross/arm64/release/src/add.co build/.objs/hello/cross/arm64/release/src/hello.co
/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/scripts/mod/modpost -m -a -o build/.objs/hello/cross/arm64/release/build/cross/ arm64/release/Module.symvers -e -N -T-
WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped.
/usr/bin/ccache /mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc -c -O2 -std=gnu89 -I/home/ruki/. xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include /generated -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi -I /home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi -I/home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include /generated/uapi -D__KERNEL__ -DMODULE -DKBUILD_MODNAME=\"hello\" -isystem /mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/../lib/gcc/aarch64-linux- gnu/7.5.0/include -include /home/ruki/.xmake/packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h -include /home/ruki/.xmake/packages/ l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h -nostdinc -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -falign-jumps=1 -falign-loops= 1 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-delete-null-pointer-checks -fno-reorder-blocks -fno- ipa-cp-clone -fno-partial-inlining -fstack-protector-strong -fno-inline-functions-called-once -falign-functions=32 -fno-strict-overflow -fno-stack-check -fconserve-stack- o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/ hello.ko.mod.c
/mnt/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-ld -EL -maarch64elf -r --build-id=sha1 -T /home/ruki/.xmake /packages/l/linux-headers/5.10.46/8f80101835834bc2866f3a827836b5de/scripts/module.lds -o build/cross/arm64/release/hello.ko build/.objs/hello/cross/arm64/release/build/cross/ arm64/release/hello.ko.o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.o
[100%]: build ok!
</code></pre>
<h2 id="asn1program">ASN.1 program</h2>
<p>ASN.1 programs need to use <a href="https://github.com/vlm/asn1c">ASN.1 Compiler</a> to generate relevant .c files to participate in project compilation.</p>
<p>While Xmake provides built-in <code>add_rules("asn1c")</code> rules to process <code>.c</code> file generation, <code>add_requires("asn1c")</code> automatically pulls and integrates ASN.1 compiler tools.</p>
<p>Here is a basic configuration example:</p>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")
add_requires("asn1c")

target("test")
     set_kind("binary")
     add_files("src/*.c")
     add_files("src/*.asn1")
     add_rules("asn1c")
     add_packages("asn1c")
</code></pre>
<p>For details, see <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/c/asn1c">Example Project</a>.</p>
<h2 id="verilogprogram">Verilog Program</h2>
<h3 id="iverilogsimulator">iVerilog Simulator</h3>
<p>Through <code>add_requires("iverilog")</code> configuration, we can automatically pull the iverilog toolchain package, and then use <code>set_toolchains("@iverilog")</code> to automatically bind the toolchain to compile the project.</p>
<pre><code class="lang-lua">add_requires("iverilog")
target("hello")
     add_rules("iverilog.binary")
     set_toolchains("@iverilog")
     add_files("src/*.v")
</code></pre>
<h4 id="setabstractconfiguration">Set abstract configuration</h4>
<pre><code class="lang-Lua">add_requires("iverilog")
target("hello")
     add_rules("iverilog.binary")
     set_toolchains("@iverilog")
     add_files("src/*.v")
     add_defines("TEST")
     add_includedirs("inc")
     set_languages("v1800-2009")
</code></pre>
<p>We can use <code>set_languages("v1800-2009")</code> to set the language standard for switching Verilog.</p>
<p>Currently supported values and mappings are as follows:</p>
<pre><code class="lang-lua">["v1364-1995"] = "-g1995"
["v1364-2001"] = "-g2001"
["v1364-2005"] = "-g2005"
["v1800-2005"] = "-g2005-sv"
["v1800-2009"] = "-g2009"
["v1800-2012"] = "-g2012"
</code></pre>
<h4 id="setcustomflags">Set custom flags</h4>
<pre><code class="lang-lua">add_requires("iverilog")
target("hello")
     add_rules("iverilog.binary")
     set_toolchains("@iverilog")
     add_files("src/*.v")
     add_values("iverilogs.flags", "-DTEST")
</code></pre>
<h4 id="buildtheproject">Build the project</h4>
<pre><code class="lang-bash">$ xmake
check iverilog... iverilog
check vvp... vvp
[50%]: linking.iverilog hello.vvp
[100%]: build ok!
</code></pre>
<h4 id="runtheprogram">Run the program</h4>
<pre><code class="lang-bash">$ xmake run
hello world!
LXT2 INFO: dumpfile hello.vcd opened, ready for output.
src/main.v:6: $finish called at 0 (1s)
</code></pre>
<p>More complete examples: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/embed/iverilog">iVerilog Examples</a></p>
<h3 id="verilatorsimulator">Verilator Simulator</h3>
<p>Through <code>add_requires("verilator")</code> configuration, we can automatically pull the verilator toolchain package, and then use <code>set_toolchains("@verilator")</code> to automatically bind to the toolchain to compile the project.</p>
<pre><code class="lang-lua">add_requires("verilator")
target("Hello")
     add_rules("verilator.binary")
     set_toolchains("@verilator")
     add_files("src/*.v")
     add_files("src/*.cpp")
</code></pre>
<p>verilator project, we need an additional <code>sim_main.cpp</code> file to participate in the compilation, as the entry code of the program.</p>
<pre><code class="lang-c">#include "hello.h"
#include "verilated.h" (Simplified Chinese)

int main(int argc, char** argv) {
     VerilatedContext* contextp = new VerilatedContext;
     contextp->commandArgs(argc, argv);
     hello* top = new hello{contextp};
     while (!contextp->gotFinish()) { top->eval(); }
     remove top.
     Remove contextp.
     returns 0.
}
</code></pre>
<h4 id="setabstractconfiguration">Set abstract configuration</h4>
<pre><code class="lang-lua">add_requires("verilator")
target("Hello")
     add_rules("verilator.binary")
     set_toolchains("@verilator")
     add_files("src/*.v")
     add_defines("TEST")
     add_includedirs("inc")
     set_languages("v1800-2009")
</code></pre>
<p>We can use <code>set_languages("v1800-2009")</code> to set the language standard for switching Verilog.</p>
<p>Currently supported values and mappings are as follows.</p>
<pre><code class="lang-lua">--Verilog
["v1364-1995"] = "+1364-1995ext+v".
["v1364-2001"] = "+1364-2001ext+v".
["v1364-2005"] = "+1364-2005ext+v".
--system-Verilog
["v1800-2005"] = "+1800-2005ext+v".
["v1800-2009"] = "+1800-2009ext+v".
["v1800-2012"] = "+1800-2012ext+v",
["v1800-2017"] = "+1800-2017ext+v".
</code></pre>
<h4 id="setcustomflags">Set custom flags</h4>
<pre><code class="lang-lua">add_requires("verilator")
target("Hello")
     add_rules("verilator.binary")
     set_toolchains("@verilator")
     add_files("src/*.v")
     add_files("src/*.cpp")
     add_values("verilator.flags", "--trace", "--timing")
</code></pre>
<h4 id="buildtheproject">Build the project</h4>
<pre><code class="lang-bash">$ xmake
[ 0%]: compiling.verilog src/main.v
[ 15%]: cache compiling.release /Users/ruki/.xmake/packages/v/verilator/2023.1.10/cd2268409c1d44799288c7759b3cbd56/share/verilator/include/verilated.cpp
[ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__Slow.cpp
[ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h9053a130__0__Slow.cpp
[ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello.cpp
[ 15%]: cache compiling.release /Users/ruki/.xmake/packages/v/verilator/2023.1.10/cd2268409c1d44799288c7759b3cbd56/share/verilator/include/verilated_threads.cpp
[ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello__Syms.cpp
[ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h07139e86__0.cpp
[15%]: cache compiling.release src/sim_main.cpp
[ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h9053a130__0.cpp
[84%]: linking. release hello
[100%]: build ok!
</code></pre>
<h4 id="runtheprogram">Run the program</h4>
<pre><code class="lang-bash">$ xmake run
ruki-2:hello ruki$ xmake run
hello world!
- src/main.v:4:Verilog $finish
</code></pre>
<p>A more complete example: <a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/embed/verilator">Verilator</a></p>
<h4 id="compilestaticlibrary">Compile static library</h4>
<p>We also provide <code>verilator.static</code> rules to compile and generate verilator static libraries.</p>
<pre><code class="lang-lua">add_requires("verilator")
target("hello")
     add_rules("verilator.static")
     set_toolchains("@verilator")
     add_files("src/*.v")

target("test")
     add_deps("hello")
     add_files("src/*.cpp")
</code></pre>
<h2 id="cppfrontprogram">Cppfront Program</h2>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

add_requires("cppfront")

target("test")
    add_rules("cppfront")
    set_kind("binary")
    add_files("src/*.cpp2")
    add_packages("cppfront")
</code></pre>
<h2 id="cosmoccprogram">Cosmocc Program</h2>
<pre><code class="lang-lua">add_rules("mode.debug", "mode.release")

add_requires("cosmocc")

target("test")
    set_kind("binary")
    add_files("src/*.c")
    set_toolchains("@cosmocc")
</code></pre>
</article>
</body>
</html>