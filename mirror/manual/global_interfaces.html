<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xmake</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="//cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h4>This is a mirror page, please see the original page: </h4><a href="https://xmake.io/#/manual/global_interfaces">https://xmake.io/#/manual/global_interfaces</a>
</br>
    <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <p>The global interface affects the whole project description scope and all sub-project files.</p>
<h3 id="includes">includes</h3>
<h4 id="addsubprojectfilesanddirectories">Add sub-project files and directories</h4>
<p>We can use this interfaces to add sub-project files (xmake.lua) or directories with xmake.lua.</p>
<pre><code>projectdir
  - subdirs
    - xmake.lua
  - src
</code></pre><p>Add sub-project directories.</p>
<pre><code class="lang-lua">includes("subdirs")

target("test")
    set_kind("binary")
    add_files("src/*.c")
</code></pre>
<p>Or add sub-project files.</p>
<pre><code class="lang-lua">includes("subdirs/xmake.lua")

target("test")
    set_kind("binary")
    add_files("src/*.c")
</code></pre>
<p>We can also recursively add multiple project sub-directory files through pattern matching.</p>
<pre><code class="lang-lua">includes("**/xmake.lua")

target("test")
    set_kind("binary")
    add_files("src/*.c")
</code></pre>
<h4 id="builtinhelpfunctions">Builtin help functions</h4>
<h5 id="automaticdetection">Automatic detection</h5>
<p>In addition, in 2.2.5 and later, this interface provides some built-in helper functions, which can be used directly after the include, specifically which built-in functions can be seen at: <a href="https://github.com/xmake-io/xmake/tree/master/xmake/includes">https://github.com/xmake-io/xmake/tree/master/xmake/includes</a></p>
<p>For a more complete description of this, see: <a href="https://github.com/xmake-io/xmake/issues/342">https://github.com/xmake-io/xmake/issues/342</a></p>
<p>Examples:</p>
<p>Check links, ctype, includes and features and write macro definitions to the config.h file.</p>
<pre><code class="lang-lua">includes("check_links.lua")
includes("check_ctypes.lua")
includes("check_cfuncs.lua")
includes("check_features.lua")
includes("check_csnippets.lua")
includes("check_cincludes.lua")

target("test")
    set_kind("binary")
    add_files("*.c")
    add_configfiles("config.h.in")

    configvar_check_ctypes("HAS_WCHAR", "wchar_t")
    configvar_check_cincludes("HAS_STRING_H", "string.h")
    configvar_check_cincludes("HAS_STRING_AND_STDIO_H", {"string.h", "stdio.h"})
    configvar_check_ctypes("HAS_WCHAR_AND_FLOAT", {"wchar_t", "float"})
    configvar_check_links("HAS_PTHREAD", {"pthread", "m", "dl"})
    configvar_check_csnippets("HAS_STATIC_ASSERT", "_Static_assert(1, \"\");")
    configvar_check_cfuncs("HAS_SETJMP", "setjmp", {includes = {"signal.h", "setjmp.h"}})
    configvar_check_features("HAS_CONSTEXPR", "cxx_constexpr")
    configvar_check_features("HAS_CONSEXPR_AND_STATIC_ASSERT", {"cxx_constexpr", "c_static_assert"}, {languages = "c++11"})
</code></pre>
<p>config.h.in</p>
<pre><code class="lang-c">${define HAS_STRING_H}
${define HAS_STRING_AND_STDIO_H}
${define HAS_WCHAR}
${define HAS_WCHAR_AND_FLOAT}
${define HAS_PTHREAD}
${define HAS_STATIC_ASSERT}
${define HAS_SETJMP}
${define HAS_CONSTEXPR}
${define HAS_CONSEXPR_AND_STATIC_ASSERT}
</code></pre>
<p>config.h</p>
<pre><code class="lang-c">/* #undef HAS_STRING_H */
#define HAS_STRING_AND_STDIO_H 1
/* #undef HAS_WCHAR */
/* #undef HAS_WCHAR_AND_FLOAT */
#define HAS_PTHREAD 1
#define HAS_STATIC_ASSERT 1
#define HAS_SETJMP 1
/* #undef HAS_CONSTEXPR */
#define HAS_CONSEXPR_AND_STATIC_ASSERT 1
</code></pre>
<p>After v2.5.7, check_csnippets has been improved, adding <code>tryrun</code> and <code>output</code> parameters to try to run and capture output.</p>
<pre><code class="lang-`lua">includes("check_csnippets.lua")

target("test")
     set_kind("binary")
     add_files("*.c")
     add_configfiles("config.h.in")

     check_csnippets("HAS_INT_4", "return (sizeof(int) == 4)? 0: -1;", {tryrun = true})
     check_csnippets("INT_SIZE",&#39;printf("%d", sizeof(int)); return 0;&#39;, {output = true, number = true})
     configvar_check_csnippets("HAS_LONG_8", "return (sizeof(long) == 8)? 0: -1;", {tryrun = true})
     configvar_check_csnippets("PTR_SIZE",&#39;printf("%d", sizeof(void*)); return 0;&#39;, {output = true, number = true})
</code></pre>
<p>If capture output is enabled, <code>${define PTR_SIZE}</code> in <code>config.h.in</code> will automatically generate <code>#define PTR_SIZE 4</code>.</p>
<p>Among them, the <code>number = true</code> setting can be forced as a number instead of a string value, otherwise it will be defined as <code>#define PTR_SIZE "4"</code> by default</p>
<h3 id="set_project">set_project</h3>
<h4 id="setprojectname">Set project name</h4>
<p>Set the whole project name, we can set it at the beginning of <code>xmake.lua</code>.</p>
<pre><code class="lang-lua">-- set project name
set_project("tbox")

-- set project version
set_version("1.5.1")
</code></pre>
<h3 id="set_version">set_version</h3>
<h4 id="setprojectversion">Set project version</h4>
<p>Set the whole project version, we can set it at the beginning of <code>xmake.lua</code>.</p>
<pre><code class="lang-lua">set_version("1.5.1")
</code></pre>
<p>We can set build version in v2.1.7 version:</p>
<pre><code class="lang-lua">set_version("1.5.1", {build = "%Y%m%d%H%M"})
</code></pre>
<p>We can also add version to the config header files, @see <a href="/mirror/manual/project_target.html#add-template-configuration-files">add_configfiles</a></p>
<h3 id="set_xmakever">set_xmakever</h3>
<h4 id="setminimalxmakeversion">Set minimal xmake version</h4>
<p>If the current xmake version less than the required version, it will prompt an error.</p>
<pre><code class="lang-lua">-- the current xmake version must be larger than 2.1.0
set_xmakever("2.1.0")
</code></pre>
<h3 id="add_moduledirs">add_moduledirs</h3>
<h4 id="addmoduledirectories">Add module directories</h4>
<p>The builtin modules are placed in the &#39;xmake/modules&#39; directory, but for user-defined modules for a specific project, you can configure additional module directories in the &#39;xmake.lua` file.</p>
<pre><code class="lang-lua">add_moduledirs("$(projectdir)/modules")
</code></pre>
<p>xmake will load the given module in the given directory when calling <code>import</code>.</p>
<h3 id="add_plugindirs">add_plugindirs</h3>
<h4 id="addplugindirectories">Add plugin directories</h4>
<p>The builtin plugins are placed in the &#39;xmake/plugins&#39; directory, but for user-defined plugins for a specific project, you can configure additional plugin directories in the &#39;xmake.lua` file.</p>
<pre><code class="lang-lua">add_plugindirs("$(projectdir)/plugins")
</code></pre>
<p>xmake will load all plugins in the given directory.</p>
<h3 id="get_config">get_config</h3>
<h4 id="gettheconfigurationvalue">Get the configuration value</h4>
<p>This interface is introduced from version 2.2.2 to get the configuration value from the given name.</p>
<pre><code class="lang-lua">if get_config("myconfig") == "xxx" then
    add_defines("HELLO")
end
</code></pre>
<h3 id="set_config">set_config</h3>
<h4 id="setthedefaultconfigurationvalue">Set the default configuration value</h4>
<p>This interface is introduced from version 2.2.2 to set the default configuration value in xmake.lua.</p>
<p>Many previous configurations, including the build toolchain, build directory, etc.<br>We can only be configured by <code>$xmake f --name=value</code>. If we want to write a default value in xmake.lua, we can use the following method:</p>
<pre><code class="lang-lua">set_config("name", "value")
set_config("buildir", "other/buildir")
set_config("cc", "gcc")
set_config("ld", "g++")
</code></pre>
<p>However, we can still modify the default configuration in xmake.lua by <code>$xmake f --name=value</code>.</p>
<h3 id="add_requires">add_requires</h3>
<h4 id="addtherequireddependencypackages">Add the required dependency packages</h4>
<p>The dependency package management of xmake fully supports semantic version selection, for example: "~1.6.1". For a detailed description of the semantic version, please see: <a href="https://semver.org/">https://semver.org/</a></p>
<h5 id="semanticversion">Semantic version</h5>
<pre><code class="lang-lua">add_requires("tbox 1.6.*", "pcre 8.x", "libpng ^1.18")
add_requires("libpng ~1.16", "zlib 1.1.2 || >=1.2.11 <1.3.0")
</code></pre>
<p>At present, the semantic version parser used by xmake is the <a href="https://github.com/uael/sv">sv</a> library contributed by <a href="https://github.com/uael">uael</a>, which also contains the version description writing method For detailed instructions, please refer to the following: <a href="https://github.com/uael/sv#versions">Version Description</a></p>
<h5 id="installlatestversion">Install latest version</h5>
<p>Of course, if we have no special requirements for the version of the current dependency package, we can write it directly like this:</p>
<pre><code class="lang-lua">add_requires("tbox", "libpng", "zlib")
</code></pre>
<p>By default, if the version number is not set, xmake will select the latest version of the package, which is equivalent to <code>add_requires("zlib latest")</code></p>
<h5 id="branchselection">Branch selection</h5>
<p>This will use the latest known version of the package, or a package compiled from the source code of the master branch. If the current package has a git repo address, we can also specify a specific branch version:</p>
<pre><code class="lang-lua">add_requires("tbox master")
add_requires("tbox dev")
</code></pre>
<p>If the specified dependent package is not supported by the current platform, or the compilation and installation fails, then xmake will compile an error. This is reasonable for some projects that must rely on certain packages to work.<br>But if some packages are optional dependencies and can be compiled and used normally even if not, they can be set as optional packages:</p>
<h5 id="optionalpackage">Optional package</h5>
<pre><code class="lang-lua">add_requires("zlib", {optional = true})
</code></pre>
<h5 id="disablesystempackage">Disable system package</h5>
<p>With the default setting, xmake will first check whether the system library exists (if the version requirement is not set). If the user does not want to use the system library and the library provided by the third-party package management at all, then you can set:</p>
<pre><code class="lang-lua">add_requires("zlib", {system = false})
</code></pre>
<h5 id="disablepackageverification">Disable package verification</h5>
<p>The default package installation will automatically check the integrity of the downloaded package to avoid tampering, but if you install some unknown new version of the package, it will not work.</p>
<p>Users can install them temporarily via <code>{verify = false}</code> to forcibly disable the package integrity check (but this is generally not recommended).</p>
<pre><code class="lang-lua">add_requires("zlib", {verify = false})
</code></pre>
<h5 id="usethedebugpackage">Use the debug package</h5>
<p>If we want to debug the dependent packages at the same time, we can set to use the debug version of the package (of course, the premise is that this package supports debug compilation):</p>
<pre><code class="lang-lua">add_requires("zlib", {debug = true})
</code></pre>
<p>If the current package does not support debug compilation, you can submit a modification to the compilation rules in the warehouse to support debugging, for example:</p>
<pre><code class="lang-lua">package("openssl")
    on_install("linux", "macosx", function (package)
        os.vrun("./config %s --prefix=\"%s\"", package:debug() and "--debug" or "", package:installdir())
        os.vrun("make -j4")
        os.vrun("make install")
    end)
</code></pre>
<h5 id="useasaprivatepackage">Use as a private package</h5>
<p>If this package is only used for package definition, and we donâ€™t want to export links/linkdirs information by default, it can be provided as a private package.</p>
<p>This is usually useful when making packages.</p>
<pre><code class="lang-lua">package("test")
    add_deps("zlib", {private = true})
    on_install(function (package)
        local zlib = package:dep("zlib"):fetch()
        - TODO
    end)
</code></pre>
<p>If you define a test package and privately rely on a zlib package, wait for the zlib installation to complete, get the package file information inside for further processing and installation, but the zlib package itself will not export links/linkdirs.</p>
<p>Although <code>add_requires</code> also supports this option, it does not export links/linkdirs, so it is usually not used in this way. It is only useful for making packages.</p>
<h5 id="usedynamiclibraries">Use dynamic libraries</h5>
<p>The default package installs a static library. If you want to enable a dynamic library, you can configure it as follows:</p>
<pre><code class="lang-lua">add_requires("zlib", {configs = {shared = true}})
</code></pre>
<p>!> Of course, the premise is that in the definition of this package, there is a judgment and processing of <code>package:config("shared")</code>. In the official xmake-repo repository, it is usually strictly differentiated and supported.</p>
<h5 id="disablepicsupport">Disable pic support</h5>
<p>The linux packages installed by default are compiled with pic enabled, which is very useful for relying on static libraries in dynamic libraries, but if you want to disable pic, it is also possible.</p>
<pre><code class="lang-lua">add_requires("zlib", {config = {pic = false}})
</code></pre>
<h5 id="setvsruntime">Set vs runtime</h5>
<p>The windows package installed by default is compiled with msvc/MT, if you want to switch to MD, you can configure it as follows:</p>
<pre><code class="lang-lua">add_requires("zlib", {config = {vs_runtime = "MD"}})
</code></pre>
<p>In addition, it supports four options: MT, MTd, MD, and MDd.</p>
<p>If there are many dependent packages, it is very troublesome to switch each configuration again. We can also switch through the <code>set_runtimes</code> global setting to take effect for all dependent packages.</p>
<pre><code class="lang-lua">set_runtimes("MD")
add_requires("zlib", "pcre2", "mbedtls")
</code></pre>
<h5 id="specificconfigurationpackage">Specific configuration package</h5>
<p>Some packages have various compilation options during compilation, and we can also pass them in:</p>
<pre><code class="lang-lua">add_requires("boost", {configs = {context = true, coroutine = true}})
</code></pre>
<p>For example, the boost package installed above has enabled some of its internal sub-module features (packages with coroutine module support).</p>
<p>Of course, which configurations are specifically supported are different for each package. You can use the <code>xmake require --info boost</code> command to view the list of the configs section inside.</p>
<p>Because, in each package definition, there will be its own configuration options, and you can use <code>package:config("coroutine")</code> to determine whether to enable them during installation.</p>
<h5 id="installthirdpartymanagerpackage">Install third-party manager package</h5>
<p>Currently, the following packages in the third-party package manager are supported.</p>
<ul>
<li>Conan (conan::openssl/1.1.1g)</li>
<li>Conda (conda::libpng 1.3.67)</li>
<li>Vcpkg (vcpkg:ffmpeg)</li>
<li>Homebrew/Linuxbrew (brew::pcre2/libpcre2-8)</li>
<li>Pacman on archlinux/msys2 (pacman::libcurl)</li>
<li>Apt on ubuntu/debian (apt::zlib1g-dev)</li>
<li>Clib (clib::<a href="mailto:clibs/bytes@0.0.4">clibs/bytes@0.0.4</a>)</li>
<li>Dub (dub::log 0.4.3)</li>
<li>Portage on Gentoo/Linux (portage::libhandy)</li>
</ul>
<p>For example, add conan&#39;s dependency package:</p>
<pre><code class="lang-lua">add_requires("conan::zlib/1.2.11", {alias = "zlib", debug = true})
add_requires("conan::openssl/1.1.1g", {alias = "openssl",
    configs = {options = "OpenSSL:shared=True"}})

target("test")
    set_kind("binary")
    add_files("src/*.c")
    add_packages("openssl", "zlib")
</code></pre>
<p>After executing xmake to compile:</p>
<pre><code class="lang-console">ruki:test_package ruki$ xmake
checking for the architecture ... x86_64
checking for the Xcode directory ... /Applications/Xcode.app
checking for the SDK version of Xcode ... 10.14
note: try installing these packages (pass -y to skip confirm)?
  -> conan::zlib/1.2.11 (debug)
  -> conan::openssl/1.1.1g
please input: y (y/n)

  => installing conan::zlib/1.2.11 .. ok
  => installing conan::openssl/1.1.1g .. ok

[0%]: ccache compiling.release src/main.c
[100%]: linking.release test
</code></pre>
<p>For a complete introduction to this and the installation and use of all third-party packages,<br>you can refer to the document: <a href="https://xmake.io/#/package/remote_package?id=install-third-party-packages">Third-party dependency package installation</a></p>
<h3 id="add_requireconfs">add_requireconfs</h3>
<h4 id="settheconfigurationofthespecifieddependentpackage">Set the configuration of the specified dependent package</h4>
<p>This is a newly added interface after v2.5.1. We can use it to expand and rewrite the configuration of the package defined by <code>add_requires()</code> and its dependent packages. It has the following uses.</p>
<h5 id="expandtheconfigurationofthespecifiedpackage">Expand the configuration of the specified package</h5>
<p>This is the basic usage. For example, we have declared a package through <code>add_requires("zlib")</code>, and want to expand the configuration of this zlib later and change it to dynamic library compilation. You can configure it in the following way.</p>
<pre><code class="lang-lua">add_requires("zlib")
add_requireconfs("zlib", {configs = {shared = true}})
</code></pre>
<p>It is equivalent to</p>
<pre><code class="lang-lua">add_requires("zlib", {configs = {shared = true}})
</code></pre>
<h5 id="setgeneraldefaultconfiguration">Set general default configuration</h5>
<p>The above usage, we still don&#39;t see any practical use, we can look at the following example first:</p>
<pre><code class="lang-lua">add_requireconfs("*", {configs = {shared = true}})
add_requires("zlib")
add_requires("pcre")
add_requires("libpng")
add_requires("libwebp")
add_requires("libcurl", {configs = {shared = false}})
</code></pre>
<p>For the above configuration, we use pattern matching through <code>add_requireconfs("*", {configs = {shared = true}})</code> to set all dependent packages to compile and install dynamic libraries by default.</p>
<p>However, we used <code>add_requires("libcurl", {configs = {shared = false}})</code> to configure libcurl to compile and install static libraries.</p>
<p>The final configuration result is: zlib/pcre/libpng/libwebp is a shared library, and libcurl is a static library.</p>
<p>Through pattern matching, we can put some common configurations of each package into the unified <code>add_requireconfs</code> to pre-configure, which greatly simplifies the definition of each <code>add_requires</code>.</p>
<p>!> By default, for the same configuration, xmake will give priority to the configuration in add_requires instead of add_requireconfs.</p>
<p>If the version is set in <code>add_requires("zlib 1.2.11")</code>, the configuration of add_requires will be used first, and the version configuration in add_requireconfs will be completely ignored. Of course, we can also completely override the version specified in <code>add_requires</code> through override .</p>
<pre><code class="lang-lua">add_requires("zlib 1.2.11")
add_requireconfs("zlib", {override = true, version = "1.2.10"})
</code></pre>
<h5 id="rewritepackagedependencyconfiguration">Rewrite package dependency configuration</h5>
<p>In fact, the biggest use of <code>add_requireconfs</code> is to allow users to rewrite the configuration of specific dependent packages of the installation package.</p>
<p>What does it mean? For example, our project integrates the package libpng and uses a dynamic library version, but the zlib library that libpng depends on is actually a static library version.</p>
<pre><code class="lang-lua">add_requires("libpng", {configs = {shared = true}})
</code></pre>
<p>So if we want to change the zlib package that libpng depends on to be compiled as a dynamic library, how should we configure it? This requires <code>add_requireconfs</code>.</p>
<pre><code class="lang-lua">add_requires("libpng", {configs = {shared = true}})
add_requireconfs("libpng.zlib", {configs = {shared = true}})
</code></pre>
<p>Through the writing method of <code>libpng.zlib</code> dependency path, specify an internal dependency and rewrite the internal dependency configuration.</p>
<p>If the dependency path is deep, such as the dependency chain of <code>foo -> bar -> xyz</code>, we can write: <code>foo.bar.xyz</code></p>
<p>We can also rewrite the internal zlib library version that libpng depends on:</p>
<pre><code class="lang-lua">add_requires("libpng")
add_requireconfs("libpng.zlib", {version = "1.2.10"})
</code></pre>
<h5 id="patternmatchingforcascadingdependencies">Pattern matching for cascading dependencies</h5>
<p>If a package has a lot of dependencies, and the dependency level is also very deep, what to do, for example, the package libwebp, its dependencies are:</p>
<pre><code>libwebp
  - libpng
    - zlib
    - cmake
  - libjpeg
  - libtiff
    - zlib
  - giflib
  - cmake
</code></pre><p>If I want to rewrite all the dependent libraries in libwebp to add specific configuration, then the configuration one by one will be very cumbersome. At this time, the recursive dependency pattern matching of <code>add_requireconfs()</code> is needed to support.</p>
<pre><code class="lang-lua">add_requires("libwebp")
add_requireconfs("libwebp.**|cmake", {configs = {cxflags = "-DTEST"}})
</code></pre>
<p>In the above configuration, we added <code>-DTEST</code> to compile all the library dependencies in libwebp, but the cmake dependency is a build tool dependency, and we can exclude it by way of <code>|xxx</code>.</p>
<p>The pattern matching here is very similar to <code>add_files()</code>.</p>
<p>We are giving a few examples. For example, this time we only rewrite the single-level dependency configuration under libwebp to enable the debugging library:</p>
<pre><code class="lang-lua">add_requires("libwebp")
add_requireconfs("libwebp.*|cmake", {debug = true})
</code></pre>
<h3 id="add_repositories">add_repositories</h3>
<h4 id="add3rdpackagerepositories">Add 3rd package repositories</h4>
<p>If the required package is not in the official repository <a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a>, we can submit the contribution code to the repository for support.<br>But if some packages are only for personal or private projects, we can create a private repository repo. The repository organization structure can be found at: <a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a></p>
<p>For example, now we have a private repository repo:<a href="mailto:`git@github.com">`git@github.com</a>:myrepo/xmake-repo.git`</p>
<p>We can add through this interface:</p>
<pre><code class="lang-lua">add_repositories("my-repo git@github.com:myrepo/xmake-repo.git")
</code></pre>
<p>If we just want to add one or two private packages, this time to build a git repository is too big, we can directly put the package repository into the project, for example:</p>
<pre><code>projectdir
  - myrepo
    - packages
      - t/tbox/xmake.lua
      - z/zlib/xmake.lua
  - src
    - main.c
  - xmake.lua
</code></pre><p>The above myrepo directory is your own private package repository, built into your own project, and then add this repository location in xmake.lua:</p>
<pre><code class="lang-lua">add_repositories("my-repo myrepo")
</code></pre>
<p>This can be referred to <a href="https://github.com/tboox/benchbox">benchbox</a> project, which has a built-in private repository.</p>
<p>Note: myrepo is the relative path of the directory where the xmake command is executed. It will not be automatically converted according to the directory where the configuration file is located. If you want to set the path relative to the current xmake.lua file, you can specify it through the rootdir parameter.</p>
<pre><code class="lang-lua">add_repositories("my-repo myrepo", {rootdir = os.scriptdir()})
</code></pre>
<p>However, this parameter setting is only supported by v2.5.7 and above.</p>
<h3 id="set_defaultplat">set_defaultplat</h3>
<h4 id="setthedefaultcompilationplatform">Set the default compilation platform</h4>
<p>Only supported by v2.5.6 and above, it is used to set the default compilation platform of the project. If it is not set, the default platform follows the current system platform, which is os.host().</p>
<p>For example, the default compilation platform on macOS is macosx, if the current project is an ios project, you can set the default compilation platform to iphoneos.</p>
<pre><code class="lang-lua">set_defaultplat("iphoneos")
</code></pre>
<p>It is equivalent to <code>xmake f -p iphoneos</code>.</p>
<h3 id="set_defaultarch">set_defaultarch</h3>
<h4 id="setthedefaultcompilationarchitecture">Set the default compilation architecture</h4>
<p>Only supported by v2.5.6 and above, it is used to set the default compilation architecture of the project. If it is not set, the default platform follows the current system architecture, which is os.arch().</p>
<pre><code class="lang-lua">set_defaultplat("iphoneos")
set_defaultarch("arm64")
</code></pre>
<p>It is equivalent to <code>xmake f -p iphoneos -a arm64</code>.</p>
<p>We can also set the default architecture under multiple platforms.</p>
<pre><code class="lang-lua">set_defaultarch("iphoneos|arm64", "windows|x64")
</code></pre>
<p>The arm64 architecture is compiled by default on iphoneos, and the x64 architecture is compiled by default on windows.</p>
<h3 id="set_defaultmode">set_defaultmode</h3>
<h4 id="setthedefaultcompilationmode">Set the default compilation mode</h4>
<p>Only supported by v2.5.6 and above, it is used to set the default compilation mode of the project. If it is not set, the default is to compile in release mode.</p>
<pre><code class="lang-lua">set_defaultmode("releasedbg")
</code></pre>
<p>It is equivalent to <code>xmake f -m releasedbg</code>.</p>
<h3 id="set_allowedplats">set_allowedplats</h3>
<h4 id="setthelistofplatformsallowedtocompile">Set the list of platforms allowed to compile</h4>
<p>It is only supported by v2.5.6 and above. It is used to set the list of compilation platforms supported by the project. If the user specifies other platforms, an error will be prompted. This is usually used to restrict the user from specifying the wrong invalid platform.</p>
<p>If it is not set, then there are no platform restrictions.</p>
<pre><code class="lang-lua">set_allowedplats("windows", "mingw")
</code></pre>
<p>Set the current project to only support windows and mingw platforms.</p>
<h3 id="set_allowedarchs">set_allowedarchs</h3>
<h4 id="settheplatformarchitecturethatallowscompilation">Set the platform architecture that allows compilation</h4>
<p>Only supported by v2.5.6 and above. It is used to set the list of compiled architectures supported by the project. If the user specifies other architectures, an error will be prompted. This is usually used to restrict users from specifying incorrect invalid architectures.</p>
<p>If it is not set, then there are no architectural restrictions.</p>
<pre><code class="lang-lua">set_allowedarchs("x64", "x86")
</code></pre>
<p>The current project only supports x64/x86 platforms.</p>
<p>We can also specify the list of architectures allowed under multiple platforms at the same time.</p>
<pre><code class="lang-lua">set_allowedarchs("windows|x64", "iphoneos|arm64")
</code></pre>
<p>Set the current project to only support x64 architecture on windows, and only support arm64 architecture on iphoneos.</p>
<h3 id="set_allowedmodes">set_allowedmodes</h3>
<h4 id="setthelistofallowedcompilationmodes">Set the list of allowed compilation modes</h4>
<p>It is only supported by v2.5.6 and above. It is used to set the list of compilation modes supported by the project. If the user specifies other modes, an error will be prompted. This is usually used to restrict the user from specifying incorrect invalid modes.</p>
<p>If it is not set, then there is no mode restriction.</p>
<pre><code class="lang-lua">set_allowedmodes("release", "releasedbg")
</code></pre>
<p>Set the current project to only support the two compilation modes release/releasedbg.</p>
</article>
</body>
</html>